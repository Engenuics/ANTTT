###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       28/Dec/2017  14:53:57
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c
#    Command line =  
#        -f C:\Users\Vipin\AppData\Local\Temp\EW46D8.tmp
#        (C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c -D NRF51
#        -lC C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\List -o
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\bsp\ -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\application\ -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\s310\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\ble_services\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\device_manager\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\app_common\
#        -I C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\drivers\ -On -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\List\anttt.lst
#    Object file  =  
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\Obj\anttt.o
#
###############################################################################

C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c
      1          /**********************************************************************************************************************
      2          File: anttt.c                                                                
      3          
      4          Description:
      5          Implements TIC-TAC-TOE using data input from ANT or BLE.
      6          
      7          
      8          
      9          **********************************************************************************************************************/
     10          
     11          #include "configuration.h"
     12          
     13          /***********************************************************************************************************************
     14          Global variable definitions with scope across entire project.
     15          All Global variable names shall start with "G_xxAnttt"
     16          ***********************************************************************************************************************/
     17          /* New variables */

   \                                 In section .bss, align 4
     18          u32 G_u32AntttFlags;                                     /* Global state flags */
   \                     G_u32AntttFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     19          fnCode_type ANTT_SM;
   \                     ANTT_SM:
   \   00000000                      DS8 4
     20          
     21          /*--------------------------------------------------------------------------------------------------------------------*/
     22          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     23          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     24          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     25          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     26          extern volatile u32 G_u32BPEngenuicsFlags;             /* From bleperipheral_engenuics.h */
     27          
     28          /***********************************************************************************************************************
     29          Global variable definitions with scope limited to this local application.
     30          Variable names shall start with "Anttt_" and be declared as static.
     31          ***********************************************************************************************************************/
     32          static u32 Anttt_u32Timeout;                             /* Timeout counter used across states */
     33          static u32 Anttt_u32CyclePeriod;                         /* Current base time for Anttt modulation */

   \                                 In section .bss, align 4
     34          static u8 Anttt_rx_data[ANTTT_COMMAND_SIZE];
   \                     Anttt_rx_data:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     35          static uint16_t Anttt_home_state;
   \                     Anttt_home_state:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     36          static uint16_t Anttt_away_state;
   \                     Anttt_away_state:
   \   00000000                      DS8 2
     37          

   \                                 In section .data, align 4
     38          u16 winning_combos[] = 
   \                     winning_combos:
   \   00000000   0x0007 0x0038      DC16 7, 56, 448, 73, 146, 292, 273, 84
   \              0x01C0 0x0049
   \              0x0092 0x0124
   \              0x0111 0x0054
     39          {
     40             0x0007,        // 0b000000111
     41             0x0038,        // 0b000111000
     42             0x01C0,        // 0b111000000
     43             0x0049,        // 0b001001001
     44             0x0092,        // 0b010010010
     45             0x0124,        // 0b100100100
     46             0x0111,        // 0b100010001
     47             0x0054        // 0b001010100
     48          };
     49          
     50          
     51          
     52          /**********************************************************************************************************************
     53          Function Definitions
     54          **********************************************************************************************************************/
     55          static void AntttSM_Idle(void);
     56          
     57          /*--------------------------------------------------------------------------------------------------------------------*/
     58          /* Public functions                                                                                                   */
     59          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     60          void AntttIncomingMessage(u8* data, u8 len)
     61          {
   \                     AntttIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     62             // Check length of the Command Size.
     63             if (len != ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttIncomingMessage_0
     64                return;
     65          
     66             memcpy(&Anttt_rx_data, data, len);
   \                     ??AntttIncomingMessage_1: (+1)
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable7
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
     67          }
   \                     ??AntttIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
     68          
     69          
     70          /*--------------------------------------------------------------------------------------------------------------------*/
     71          /* Protected functions                                                                                                */
     72          /*--------------------------------------------------------------------------------------------------------------------*/
     73          
     74          /*--------------------------------------------------------------------------------------------------------------------
     75          Function: AntttInitialize
     76          
     77          Description:
     78          Initializes the State Machine and its variables.
     79          
     80          Requires:
     81          
     82          Promises:
     83          */

   \                                 In section .text, align 2, keep-with-next
     84          void AntttInitialize(void)
     85          {
   \                     AntttInitialize: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     86             memset(Anttt_rx_data, 0xFF, ANTTT_COMMAND_SIZE);
   \   00000002   0x2503             MOVS     R5,#+3
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x....             LDR      R6,??DataTable7
   \   00000008   0x0022             MOVS     R2,R4
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
     87             Anttt_home_state = Anttt_away_state = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR      R1,??DataTable7_1
   \   00000016   0x8008             STRH     R0,[R1, #+0]
   \   00000018   0x....             LDR      R0,??DataTable7_1
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable7_2
   \   0000001E   0x8008             STRH     R0,[R1, #+0]
     88             ANTT_SM = &AntttSM_Idle;
   \   00000020   0x....             LDR      R0,??DataTable7_3
   \   00000022   0x....             LDR      R1,??DataTable7_4
   \   00000024   0x6008             STR      R0,[R1, #+0]
     89          
     90             // Set up initial LEDs.
     91             LedOn(STATUS_YLW);
   \   00000026   0x2013             MOVS     R0,#+19
   \   00000028   0x.... 0x....      BL       LedOn
     92             LedOff(STATUS_RED);
   \   0000002C   0x2012             MOVS     R0,#+18
   \   0000002E   0x.... 0x....      BL       LedOff
     93             LedOff(STATUS_GRN);
   \   00000032   0x2014             MOVS     R0,#+20
   \   00000034   0x.... 0x....      BL       LedOff
     94          } /* end AntttInitialize() */
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
     95          

   \                                 In section .text, align 2, keep-with-next
     96          void AntttHandleIncomingMessage(u8* data, u8 len)
     97          {
   \                     AntttHandleIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     98             // Check the appropriate length.
     99             if (len == ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttHandleIncomingMessage_0
    100             {
    101                memcpy(Anttt_rx_data, data, len);
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable7
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
    102             }
    103          }
   \                     ??AntttHandleIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    104          
    105          
    106          /*--------------------------------------------------------------------------------------------------------------------*/
    107          /* Private functions                                                                                                  */
    108          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    109          static bool Anttt_is_game_over(void)
    110          {
   \                     Anttt_is_game_over: (+1)
   \   00000000   0xB500             PUSH     {LR}
    111             // Check all 8 winning combinations.
    112             for (int i = 0; i < 8; i++)
   \   00000002   0x2100             MOVS     R1,#+0
   \                     ??Anttt_is_game_over_0: (+1)
   \   00000004   0x2908             CMP      R1,#+8
   \   00000006   0xDA2F             BGE      ??Anttt_is_game_over_1
    113             {
    114                if (Anttt_home_state & winning_combos[i])
   \   00000008   0x....             LDR      R0,??DataTable7_2
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x....             LDR      R2,??DataTable7_5
   \   0000000E   0x2302             MOVS     R3,#+2
   \   00000010   0x434B             MULS     R3,R1,R3
   \   00000012   0x5AD2             LDRH     R2,[R2, R3]
   \   00000014   0x4210             TST      R0,R2
   \   00000016   0xD00E             BEQ      ??Anttt_is_game_over_2
    115                {
    116                   Anttt_home_state = winning_combos[i];
   \   00000018   0x....             LDR      R0,??DataTable7_5
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0x434A             MULS     R2,R1,R2
   \   0000001E   0x5A80             LDRH     R0,[R0, R2]
   \   00000020   0x....             LDR      R2,??DataTable7_2
   \   00000022   0x8010             STRH     R0,[R2, #+0]
    117                   Anttt_home_state |= 0x200;       // Set this flag to indicate home won.
   \   00000024   0x....             LDR      R0,??DataTable7_2
   \   00000026   0x8800             LDRH     R0,[R0, #+0]
   \   00000028   0x2280             MOVS     R2,#+128
   \   0000002A   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   0000002C   0x4302             ORRS     R2,R2,R0
   \   0000002E   0x....             LDR      R0,??DataTable7_2
   \   00000030   0x8002             STRH     R2,[R0, #+0]
    118          
    119                   return true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE019             B        ??Anttt_is_game_over_3
    120                }
    121                else if (Anttt_away_state & winning_combos[i])
   \                     ??Anttt_is_game_over_2: (+1)
   \   00000036   0x....             LDR      R0,??DataTable7_1
   \   00000038   0x8800             LDRH     R0,[R0, #+0]
   \   0000003A   0x....             LDR      R2,??DataTable7_5
   \   0000003C   0x2302             MOVS     R3,#+2
   \   0000003E   0x434B             MULS     R3,R1,R3
   \   00000040   0x5AD2             LDRH     R2,[R2, R3]
   \   00000042   0x4210             TST      R0,R2
   \   00000044   0xD00E             BEQ      ??Anttt_is_game_over_4
    122                {
    123                   Anttt_away_state = winning_combos[i];
   \   00000046   0x....             LDR      R0,??DataTable7_5
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0x434A             MULS     R2,R1,R2
   \   0000004C   0x5A80             LDRH     R0,[R0, R2]
   \   0000004E   0x....             LDR      R2,??DataTable7_1
   \   00000050   0x8010             STRH     R0,[R2, #+0]
    124                   Anttt_away_state |= 0x200;       // Set this flag to indicate away winning won.
   \   00000052   0x....             LDR      R0,??DataTable7_1
   \   00000054   0x8800             LDRH     R0,[R0, #+0]
   \   00000056   0x2280             MOVS     R2,#+128
   \   00000058   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   0000005A   0x4302             ORRS     R2,R2,R0
   \   0000005C   0x....             LDR      R0,??DataTable7_1
   \   0000005E   0x8002             STRH     R2,[R0, #+0]
    125          
    126                   return true;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xE002             B        ??Anttt_is_game_over_3
    127                }
    128             }
   \                     ??Anttt_is_game_over_4: (+1)
   \   00000064   0x1C49             ADDS     R1,R1,#+1
   \   00000066   0xE7CD             B        ??Anttt_is_game_over_0
    129          
    130             return false;
   \                     ??Anttt_is_game_over_1: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??Anttt_is_game_over_3: (+1)
   \   0000006A   0xBD00             POP      {PC}             ;; return
    131          }
    132          
    133          
    134          /*--------------------------------------------------------------------------------------------------------------------*/
    135          /* State Machine definitions                                                                                          */
    136          /*--------------------------------------------------------------------------------------------------------------------*/
    137          /*--------------------------------------------------------------------------------------------------------------------
    138          Function: AntttSM_Idle
    139          */

   \                                 In section .text, align 2, keep-with-next
    140          static void AntttSM_Idle(void)
    141          {
   \                     AntttSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    142             // Check if module is connected to client.
    143             if (G_u32BPEngenuicsFlags == BPENGENUICS_CONNECTED)
   \   00000002   0x....             LDR      R0,??DataTable7_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE      ??AntttSM_Idle_0
    144             {
    145                // Set LEDs and proceed to wait state.
    146                LedOn(STATUS_GRN);   // Connected to Client.
   \   0000000A   0x2014             MOVS     R0,#+20
   \   0000000C   0x.... 0x....      BL       LedOn
    147                LedOn(STATUS_RED);   // Waiting on Client to make first move.
   \   00000010   0x2012             MOVS     R0,#+18
   \   00000012   0x.... 0x....      BL       LedOn
    148                LedOff(STATUS_YLW);  // Status LED off
   \   00000016   0x2013             MOVS     R0,#+19
   \   00000018   0x.... 0x....      BL       LedOff
    149          
    150                ANTT_SM = &AntttSM_Wait;
   \   0000001C   0x....             LDR      R0,??DataTable7_7
   \   0000001E   0x....             LDR      R1,??DataTable7_4
   \   00000020   0x6008             STR      R0,[R1, #+0]
    151             }
    152          } 
   \                     ??AntttSM_Idle_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    153          

   \                                 In section .text, align 2, keep-with-next
    154          static void AntttSM_Wait(void)
    155          {
   \                     AntttSM_Wait: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    156             // Check if module has established connection with client.
    157             if (G_u32BPEngenuicsFlags & BPENGENUICS_SERVICEENABLED)
   \   00000002   0x....             LDR      R0,??DataTable7_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD536             BPL      ??AntttSM_Wait_0
    158             {
    159                // Wait for Client to make a move.
    160                if (Anttt_rx_data[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE)
   \   0000000A   0x....             LDR      R0,??DataTable7
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x28CC             CMP      R0,#+204
   \   00000010   0xD134             BNE      ??AntttSM_Wait_1
    161                {
    162                   u8 temp[ANTTT_COMMAND_SIZE];
    163                   u16  position = Anttt_rx_data[ANTTT_COMMAND_POSITION_OFFSET];
   \   00000012   0x....             LDR      R0,??DataTable7
   \   00000014   0x7846             LDRB     R6,[R0, #+1]
    164                   
    165                   // Check if position is already chosen.
    166                   if (Anttt_away_state & (1 << (position-1)))
   \   00000016   0x....             LDR      R0,??DataTable7_1
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x0032             MOVS     R2,R6
   \   0000001E   0x1E52             SUBS     R2,R2,#+1
   \   00000020   0x4091             LSLS     R1,R1,R2
   \   00000022   0x4208             TST      R0,R1
   \   00000024   0xD12A             BNE      ??AntttSM_Wait_2
    167                   {
    168                      return;
    169                   }
    170          
    171                   // New Position.
    172                   LedOn(position + 9);  // 9 is the offset for away LEDs.
                                ^
Warning[Pe188]: enumerated type mixed with another type
   \                     ??AntttSM_Wait_3: (+1)
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x3009             ADDS     R0,R0,#+9
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       LedOn
    173                   Anttt_away_state = 1 << (position - 1);
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x1E49             SUBS     R1,R1,#+1
   \   00000036   0x4088             LSLS     R0,R0,R1
   \   00000038   0x....             LDR      R1,??DataTable7_1
   \   0000003A   0x8008             STRH     R0,[R1, #+0]
    174                   
    175                   // Send response.
    176                   temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE_RESP;
   \   0000003C   0x20AC             MOVS     R0,#+172
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    177                   BPEngenuicsSendData(temp, ANTTT_COMMAND_SIZE);
   \   00000042   0x2103             MOVS     R1,#+3
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       BPEngenuicsSendData
    178          
    179                   if (Anttt_is_game_over())
   \   0000004A   0x.... 0x....      BL       Anttt_is_game_over
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD003             BEQ      ??AntttSM_Wait_4
    180                   {
    181                      ANTT_SM = &AntttSM_Gameover;
   \   00000052   0x....             LDR      R0,??DataTable7_8
   \   00000054   0x....             LDR      R1,??DataTable7_4
   \   00000056   0x6008             STR      R0,[R1, #+0]
    182                      return;
   \   00000058   0xE010             B        ??AntttSM_Wait_2
    183                   }
    184                   
    185                   memset(Anttt_rx_data, 0xFF, ANTTT_COMMAND_SIZE);   // Reset message.
   \                     ??AntttSM_Wait_4: (+1)
   \   0000005A   0x2503             MOVS     R5,#+3
   \   0000005C   0x24FF             MOVS     R4,#+255
   \   0000005E   0x....             LDR      R7,??DataTable7
   \   00000060   0x0022             MOVS     R2,R4
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       __aeabi_memset
    186          
    187                   // Update State.
    188                   ANTT_SM = &AntttSM_Active;
   \   0000006A   0x....             LDR      R0,??DataTable7_9
   \   0000006C   0x....             LDR      R1,??DataTable7_4
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    189                   LedOff(STATUS_RED);
   \   00000070   0x2012             MOVS     R0,#+18
   \   00000072   0x.... 0x....      BL       LedOff
   \   00000076   0xE001             B        ??AntttSM_Wait_1
    190                }
    191             }
    192             else
    193             {
    194                // Disconnected from client.
    195                AntttInitialize();
   \                     ??AntttSM_Wait_0: (+1)
   \   00000078   0x.... 0x....      BL       AntttInitialize
    196             }
    197          }
   \                     ??AntttSM_Wait_1: (+1)
   \                     ??AntttSM_Wait_2: (+1)
   \   0000007C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    198          

   \                                 In section .text, align 2, keep-with-next
    199          static void AntttSM_Active(void)
    200          {
   \                     AntttSM_Active: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    201             // Check if module has established connection with client.
    202             if (G_u32BPEngenuicsFlags & BPENGENUICS_SERVICEENABLED)
   \   00000002   0x....             LDR      R0,??DataTable7_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD51A             BPL      ??AntttSM_Active_0
    203             {
    204                // Make a move.
    205                // TODO:
    206          
    207                
    208                // Check if response received.
    209                if (Anttt_rx_data[ANTTT_COMMAND_ID_OFFSET] != ANTTT_COMMAND_ID_MOVE_RESP)
   \   0000000A   0x....             LDR      R0,??DataTable7
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x28AC             CMP      R0,#+172
   \   00000010   0xD018             BEQ      ??AntttSM_Active_1
    210                {
    211                   memset(Anttt_rx_data, 0xFF, ANTTT_COMMAND_SIZE);   // Reset message.
   \   00000012   0x2503             MOVS     R5,#+3
   \   00000014   0x24FF             MOVS     R4,#+255
   \   00000016   0x....             LDR      R6,??DataTable7
   \   00000018   0x0022             MOVS     R2,R4
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x.... 0x....      BL       __aeabi_memset
    212          
    213                   // Check if game is over.
    214                   if (Anttt_is_game_over())
   \   00000022   0x.... 0x....      BL       Anttt_is_game_over
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD003             BEQ      ??AntttSM_Active_2
    215                   {
    216                      ANTT_SM = &AntttSM_Gameover;
   \   0000002A   0x....             LDR      R0,??DataTable7_8
   \   0000002C   0x....             LDR      R1,??DataTable7_4
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    217                      return;
   \   00000030   0xE008             B        ??AntttSM_Active_3
    218                   }
    219                  
    220                   // Update State.
    221                   ANTT_SM = &AntttSM_Wait;
   \                     ??AntttSM_Active_2: (+1)
   \   00000032   0x....             LDR      R0,??DataTable7_7
   \   00000034   0x....             LDR      R1,??DataTable7_4
   \   00000036   0x6008             STR      R0,[R1, #+0]
    222                   LedOn(STATUS_RED);
   \   00000038   0x2012             MOVS     R0,#+18
   \   0000003A   0x.... 0x....      BL       LedOn
   \   0000003E   0xE001             B        ??AntttSM_Active_1
    223                }
    224             }
    225             else
    226             {
    227                // Disconnected from client.
    228                AntttInitialize();
   \                     ??AntttSM_Active_0: (+1)
   \   00000040   0x.... 0x....      BL       AntttInitialize
    229             }
    230          }
   \                     ??AntttSM_Active_1: (+1)
   \                     ??AntttSM_Active_3: (+1)
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    231          

   \                                 In section .text, align 2, keep-with-next
    232          static void AntttSM_Gameover(void)
    233          {   
   \                     AntttSM_Gameover: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    234             // Play Winning Sequence. 
    235             if (G_u32SystemTime1ms % 500)
   \   00000004   0x....             LDR      R0,??DataTable7_10
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x21FA             MOVS     R1,#+250
   \   0000000A   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \   0000000C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD051             BEQ      ??AntttSM_Gameover_0
    236             {
    237                // Toggle LED sequences.
    238                LedToggle(STATUS_GRN);
   \   00000014   0x2014             MOVS     R0,#+20
   \   00000016   0x.... 0x....      BL       LedToggle
    239                LedToggle(STATUS_RED);
   \   0000001A   0x2012             MOVS     R0,#+18
   \   0000001C   0x.... 0x....      BL       LedToggle
    240                LedToggle(STATUS_YLW);
   \   00000020   0x2013             MOVS     R0,#+19
   \   00000022   0x.... 0x....      BL       LedToggle
    241          
    242                // Blink winning sequence.
    243                if (Anttt_home_state & 0x200)
   \   00000026   0x....             LDR      R0,??DataTable7_2
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x0580             LSLS     R0,R0,#+22
   \   0000002C   0xD522             BPL      ??AntttSM_Gameover_1
    244                {
    245                   // Home won.
    246                   u8 three[3];
    247                   u8 index = 0;
   \   0000002E   0x2400             MOVS     R4,#+0
    248          
    249                   // Convert LED bitmask to LED value.
    250                   for (int i = 0; i < 9; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_2: (+1)
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xDA11             BGE      ??AntttSM_Gameover_3
    251                   {
    252                      if (Anttt_home_state & 0x01)
   \   00000036   0x....             LDR      R1,??DataTable7_2
   \   00000038   0x7809             LDRB     R1,[R1, #+0]
   \   0000003A   0x07C9             LSLS     R1,R1,#+31
   \   0000003C   0xD505             BPL      ??AntttSM_Gameover_4
    253                      {
    254                         three[index++] = i + 1;
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0x466A             MOV      R2,SP
   \   00000044   0xB2E4             UXTB     R4,R4
   \   00000046   0x5511             STRB     R1,[R2, R4]
   \   00000048   0x1C64             ADDS     R4,R4,#+1
    255                      }
    256          
    257                      Anttt_home_state = Anttt_home_state >> 1;
   \                     ??AntttSM_Gameover_4: (+1)
   \   0000004A   0x....             LDR      R1,??DataTable7_2
   \   0000004C   0x8809             LDRH     R1,[R1, #+0]
   \   0000004E   0xB289             UXTH     R1,R1
   \   00000050   0x0849             LSRS     R1,R1,#+1
   \   00000052   0x....             LDR      R2,??DataTable7_2
   \   00000054   0x8011             STRH     R1,[R2, #+0]
    258                   }
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0xE7EB             B        ??AntttSM_Gameover_2
    259          
    260                   LedToggle(three[0]);
                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \                     ??AntttSM_Gameover_3: (+1)
   \   0000005A   0x4668             MOV      R0,SP
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       LedToggle
    261                   LedToggle(three[1]);
                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x7840             LDRB     R0,[R0, #+1]
   \   00000066   0x.... 0x....      BL       LedToggle
    262                   LedToggle(three[2]);
                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x7880             LDRB     R0,[R0, #+2]
   \   0000006E   0x.... 0x....      BL       LedToggle
   \   00000072   0xE021             B        ??AntttSM_Gameover_0
    263                }
    264                else
    265                {
    266                   // Away won.
    267                   u8 three[3];
    268                   u8 index = 0;
   \                     ??AntttSM_Gameover_1: (+1)
   \   00000074   0x2400             MOVS     R4,#+0
    269          
    270                   // Convert LED bitmask to LED value.
    271                   for (int i = 0; i < 9; i++)
   \   00000076   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_5: (+1)
   \   00000078   0x2809             CMP      R0,#+9
   \   0000007A   0xDA11             BGE      ??AntttSM_Gameover_6
    272                   {
    273                      if (Anttt_away_state & 0x01)
   \   0000007C   0x....             LDR      R1,??DataTable7_1
   \   0000007E   0x7809             LDRB     R1,[R1, #+0]
   \   00000080   0x07C9             LSLS     R1,R1,#+31
   \   00000082   0xD505             BPL      ??AntttSM_Gameover_7
    274                      {
    275                         three[index++] = i + 1;
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x1C49             ADDS     R1,R1,#+1
   \   00000088   0x466A             MOV      R2,SP
   \   0000008A   0xB2E4             UXTB     R4,R4
   \   0000008C   0x5511             STRB     R1,[R2, R4]
   \   0000008E   0x1C64             ADDS     R4,R4,#+1
    276                      }
    277          
    278                      Anttt_away_state = Anttt_away_state >> 1;
   \                     ??AntttSM_Gameover_7: (+1)
   \   00000090   0x....             LDR      R1,??DataTable7_1
   \   00000092   0x8809             LDRH     R1,[R1, #+0]
   \   00000094   0xB289             UXTH     R1,R1
   \   00000096   0x0849             LSRS     R1,R1,#+1
   \   00000098   0x....             LDR      R2,??DataTable7_1
   \   0000009A   0x8011             STRH     R1,[R2, #+0]
    279                   }
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0xE7EB             B        ??AntttSM_Gameover_5
    280          
    281                   LedToggle(three[0]);
                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \                     ??AntttSM_Gameover_6: (+1)
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x.... 0x....      BL       LedToggle
    282                   LedToggle(three[1]);
                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \   000000A8   0x4668             MOV      R0,SP
   \   000000AA   0x7840             LDRB     R0,[R0, #+1]
   \   000000AC   0x.... 0x....      BL       LedToggle
    283                   LedToggle(three[2]);
                                    ^
Warning[Pe188]: enumerated type mixed with another type

  static u32 Anttt_u32Timeout;                             /* Timeout counter used across states */
             ^
"C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c",32  Warning[Pe177]: 
          variable "Anttt_u32Timeout" was declared but never referenced

  static u32 Anttt_u32CyclePeriod;                         /* Current base time for Anttt modulation */
             ^
"C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c",33  Warning[Pe177]: 
          variable "Anttt_u32CyclePeriod" was declared but never referenced
   \   000000B0   0x4668             MOV      R0,SP
   \   000000B2   0x7880             LDRB     R0,[R0, #+2]
   \   000000B4   0x.... 0x....      BL       LedToggle
    284                }
    285             }
    286          
    287             // TODO: Reset SM once a button is pressed.
    288          }
   \                     ??AntttSM_Gameover_0: (+1)
   \   000000B8   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     Anttt_rx_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     Anttt_away_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     Anttt_home_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     AntttSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     ANTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     winning_combos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     G_u32BPEngenuicsFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     AntttSM_Wait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     AntttSM_Gameover

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     AntttSM_Active

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     G_u32SystemTime1ms
    289          /*--------------------------------------------------------------------------------------------------------------------*/
    290          /* End of File                                                                                                        */
    291          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AntttHandleIncomingMessage
        16   -> __aeabi_memcpy
      16   AntttIncomingMessage
        16   -> __aeabi_memcpy
      16   AntttInitialize
        16   -> LedOff
        16   -> LedOn
        16   -> __aeabi_memset
      16   AntttSM_Active
        16   -> AntttInitialize
        16   -> Anttt_is_game_over
        16   -> LedOn
        16   -> __aeabi_memset
      16   AntttSM_Gameover
        16   -> LedToggle
        16 __aeabi_uidivmod
       8   AntttSM_Idle
         8   -> LedOff
         8   -> LedOn
      24   AntttSM_Wait
        24   -> AntttInitialize
        24   -> Anttt_is_game_over
        24   -> BPEngenuicsSendData
        24   -> LedOff
        24   -> LedOn
        24   -> __aeabi_memset
       4   Anttt_is_game_over


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       4  ANTT_SM
      28  AntttHandleIncomingMessage
      28  AntttIncomingMessage
      58  AntttInitialize
      70  AntttSM_Active
     186  AntttSM_Gameover
      36  AntttSM_Idle
     126  AntttSM_Wait
       2  Anttt_away_state
       2  Anttt_home_state
     108  Anttt_is_game_over
       4  Anttt_rx_data
       4  G_u32AntttFlags
      16  winning_combos

 
  16 bytes in section .bss
  16 bytes in section .data
 684 bytes in section .text
 
 684 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: 9
