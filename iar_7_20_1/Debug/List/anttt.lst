###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       31/Dec/2017  15:45:59
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c
#    Command line =  
#        -f C:\Users\Vipin\AppData\Local\Temp\EWF4A5.tmp
#        (C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c -D NRF51
#        -lC C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\List -o
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\bsp\ -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\application\ -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\s310\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\ble_services\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\device_manager\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\app_common\
#        -I C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\drivers\ -On -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\List\anttt.lst
#    Object file  =  
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\Obj\anttt.o
#
###############################################################################

C:\Users\Vipin\Documents\GitHub\ANTTT\application\anttt.c
      1          /**********************************************************************************************************************
      2          File: anttt.c                                                                
      3          
      4          Description:
      5          Implements TIC-TAC-TOE using data input from ANT or BLE.
      6          
      7          
      8          
      9          **********************************************************************************************************************/
     10          
     11          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_clear(uint32_t)
   \                     nrf_gpio_pin_clear: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable8  ;; 0x5000050c
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_toggle(uint32_t)
   \                     nrf_gpio_pin_toggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4081             LSLS     R1,R1,R0
   \   00000006   0x....             LDR      R2,??DataTable8_1  ;; 0x50000504
   \   00000008   0x6813             LDR      R3,[R2, #+0]
   \   0000000A   0x40C3             LSRS     R3,R3,R0
   \   0000000C   0x001A             MOVS     R2,R3
   \   0000000E   0x07D2             LSLS     R2,R2,#+31       ;; ZeroExtS R2,R2,#+31,#+31
   \   00000010   0x0FD2             LSRS     R2,R2,#+31
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD102             BNE      ??nrf_gpio_pin_toggle_0
   \   00000016   0x....             LDR      R3,??DataTable8_2  ;; 0x50000508
   \   00000018   0x6019             STR      R1,[R3, #+0]
   \   0000001A   0xE001             B        ??nrf_gpio_pin_toggle_1
   \                     ??nrf_gpio_pin_toggle_0: (+1)
   \   0000001C   0x....             LDR      R3,??DataTable8  ;; 0x5000050c
   \   0000001E   0x6019             STR      R1,[R3, #+0]
   \                     ??nrf_gpio_pin_toggle_1: (+1)
   \   00000020   0xBD00             POP      {PC}             ;; return
     12          
     13          /***********************************************************************************************************************
     14          Global variable definitions with scope across entire project.
     15          All Global variable names shall start with "G_xxAnttt"
     16          ***********************************************************************************************************************/
     17          /* New variables */

   \                                 In section .bss, align 4
     18          u32 G_u32AntttFlags;                                     /* Global state flags */
   \                     G_u32AntttFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     19          fnCode_type ANTT_SM;
   \                     ANTT_SM:
   \   00000000                      DS8 4
     20          
     21          /*--------------------------------------------------------------------------------------------------------------------*/
     22          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     23          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     24          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     25          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     26          extern volatile u32 G_u32BPEngenuicsFlags;             /* From bleperipheral_engenuics.h */
     27          
     28          /***********************************************************************************************************************
     29          Global variable definitions with scope limited to this local application.
     30          Variable names shall start with "Anttt_" and be declared as static.
     31          ***********************************************************************************************************************/
     32          static u32 Anttt_u32Timeout;                             /* Timeout counter used across states */
                            ^
Warning[Pe177]: variable "Anttt_u32Timeout" was declared but never referenced
     33          static u32 Anttt_u32CyclePeriod;                         /* Current base time for Anttt modulation */
                            ^
Warning[Pe177]: variable "Anttt_u32CyclePeriod" was declared but never
          referenced

   \                                 In section .bss, align 4
     34          static u8 Anttt_rx_data[ANTTT_COMMAND_SIZE];
   \                     Anttt_rx_data:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
     35          static uint16_t Anttt_home_state;
   \                     Anttt_home_state:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     36          static uint16_t Anttt_away_state;
   \                     Anttt_away_state:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     37          static bool bPendingResponse;
   \                     bPendingResponse:
   \   00000000                      DS8 1
     38          

   \                                 In section .data, align 4
     39          u16 winning_combos[] = 
   \                     winning_combos:
   \   00000000   0x0007 0x0038      DC16 7, 56, 448, 73, 146, 292, 273, 84
   \              0x01C0 0x0049
   \              0x0092 0x0124
   \              0x0111 0x0054
     40          {
     41            0x0007,        // 0b000000111
     42            0x0038,        // 0b000111000
     43            0x01C0,        // 0b111000000
     44            0x0049,        // 0b001001001
     45            0x0092,        // 0b010010010
     46            0x0124,        // 0b100100100
     47            0x0111,        // 0b100010001
     48            0x0054         // 0b001010100
     49          };
     50          
     51          
     52          
     53          /**********************************************************************************************************************
     54          Function Definitions
     55          **********************************************************************************************************************/
     56          static void AntttSM_Idle(void);
     57          
     58          /*--------------------------------------------------------------------------------------------------------------------*/
     59          /* Public functions                                                                                                   */
     60          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     61          void AntttIncomingMessage(u8* data, u8 len)
     62          {
   \                     AntttIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     63            // Check length of the Command Size.
     64            if (len != ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttIncomingMessage_0
     65              return;
     66            
     67            memcpy(&Anttt_rx_data, data, len);
   \                     ??AntttIncomingMessage_1: (+1)
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable8_3
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
     68          }
   \                     ??AntttIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
     69          
     70          
     71          /*--------------------------------------------------------------------------------------------------------------------*/
     72          /* Protected functions                                                                                                */
     73          /*--------------------------------------------------------------------------------------------------------------------*/
     74          
     75          /*--------------------------------------------------------------------------------------------------------------------
     76          Function: AntttInitialize
     77          
     78          Description:
     79          Initializes the State Machine and its variables.
     80          
     81          Requires:
     82          
     83          Promises:
     84          */

   \                                 In section .text, align 2, keep-with-next
     85          void AntttInitialize(void)
     86          {
   \                     AntttInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     87            Anttt_reset_rx_buffer();
   \   00000002   0x.... 0x....      BL       Anttt_reset_rx_buffer
     88            Anttt_home_state = Anttt_away_state = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable8_4
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
   \   0000000C   0x....             LDR      R0,??DataTable8_4
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0x....             LDR      R1,??DataTable8_5
   \   00000012   0x8008             STRH     R0,[R1, #+0]
     89            ANTT_SM = &AntttSM_Idle;
   \   00000014   0x....             LDR      R0,??DataTable8_6
   \   00000016   0x....             LDR      R1,??DataTable8_7
   \   00000018   0x6008             STR      R0,[R1, #+0]
     90            bPendingResponse = false;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR      R1,??DataTable9
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
     91            
     92            // Set up initial LEDs.
     93            LedOn(STATUS_RED);
   \   00000020   0x2012             MOVS     R0,#+18
   \   00000022   0x.... 0x....      BL       LedOn
     94            LedOff(STATUS_YLW);
   \   00000026   0x2013             MOVS     R0,#+19
   \   00000028   0x.... 0x....      BL       LedOff
     95            LedOff(STATUS_GRN);
   \   0000002C   0x2014             MOVS     R0,#+20
   \   0000002E   0x.... 0x....      BL       LedOff
     96            
     97            for (int led = 0; led < TOTAL_BUTTONS * 2; led++)
   \   00000032   0x2400             MOVS     R4,#+0
   \                     ??AntttInitialize_0: (+1)
   \   00000034   0x2C12             CMP      R4,#+18
   \   00000036   0xDA05             BGE      ??AntttInitialize_1
     98              LedOff((LedNumberType) led);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x.... 0x....      BL       LedOff
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   \   00000042   0xE7F7             B        ??AntttInitialize_0
     99            
    100            nrf_gpio_pin_clear(16);
   \                     ??AntttInitialize_1: (+1)
   \   00000044   0x2010             MOVS     R0,#+16
   \   00000046   0x.... 0x....      BL       nrf_gpio_pin_clear
    101            
    102          } /* end AntttInitialize() */
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void AntttHandleIncomingMessage(u8* data, u8 len)
    105          {
   \                     AntttHandleIncomingMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    106            // Check the appropriate length.
    107            if (len == ANTTT_COMMAND_SIZE)
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D03             CMP      R5,#+3
   \   0000000A   0xD106             BNE      ??AntttHandleIncomingMessage_0
    108            {
    109              memcpy(Anttt_rx_data, data, len);
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x....             LDR      R6,??DataTable9_1
   \   00000010   0x002A             MOVS     R2,R5
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
    110            }
    111          }
   \                     ??AntttHandleIncomingMessage_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    112          
    113          
    114          /*--------------------------------------------------------------------------------------------------------------------*/
    115          /* Private functions                                                                                                  */
    116          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    117          static bool Anttt_is_game_over(void)
    118          {
   \                     Anttt_is_game_over: (+1)
   \   00000000   0xB500             PUSH     {LR}
    119            // Check all 8 winning combinations.
    120            for (int i = 0; i < 8; i++)
   \   00000002   0x2100             MOVS     R1,#+0
   \                     ??Anttt_is_game_over_0: (+1)
   \   00000004   0x2908             CMP      R1,#+8
   \   00000006   0xDA39             BGE      ??Anttt_is_game_over_1
    121            {
    122              if ((Anttt_home_state & winning_combos[i]) == winning_combos[i])
   \   00000008   0x....             LDR      R0,??DataTable8_5
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0x....             LDR      R2,??DataTable8_8
   \   0000000E   0x2302             MOVS     R3,#+2
   \   00000010   0x434B             MULS     R3,R1,R3
   \   00000012   0x5AD2             LDRH     R2,[R2, R3]
   \   00000014   0x4002             ANDS     R2,R2,R0
   \   00000016   0x....             LDR      R0,??DataTable8_8
   \   00000018   0x2302             MOVS     R3,#+2
   \   0000001A   0x434B             MULS     R3,R1,R3
   \   0000001C   0x5AC0             LDRH     R0,[R0, R3]
   \   0000001E   0x4282             CMP      R2,R0
   \   00000020   0xD10E             BNE      ??Anttt_is_game_over_2
    123              {
    124                Anttt_home_state = winning_combos[i];
   \   00000022   0x....             LDR      R0,??DataTable8_8
   \   00000024   0x2202             MOVS     R2,#+2
   \   00000026   0x434A             MULS     R2,R1,R2
   \   00000028   0x5A80             LDRH     R0,[R0, R2]
   \   0000002A   0x....             LDR      R2,??DataTable8_5
   \   0000002C   0x8010             STRH     R0,[R2, #+0]
    125                Anttt_home_state |= 0x200;       // Set this flag to indicate home won.
   \   0000002E   0x....             LDR      R0,??DataTable8_5
   \   00000030   0x8800             LDRH     R0,[R0, #+0]
   \   00000032   0x2280             MOVS     R2,#+128
   \   00000034   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   00000036   0x4302             ORRS     R2,R2,R0
   \   00000038   0x....             LDR      R0,??DataTable8_5
   \   0000003A   0x8002             STRH     R2,[R0, #+0]
    126                
    127                return true;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE028             B        ??Anttt_is_game_over_3
    128              }
    129              else if ((Anttt_away_state & winning_combos[i]) == winning_combos[i])
   \                     ??Anttt_is_game_over_2: (+1)
   \   00000040   0x....             LDR      R0,??DataTable8_4
   \   00000042   0x8800             LDRH     R0,[R0, #+0]
   \   00000044   0x....             LDR      R2,??DataTable8_8
   \   00000046   0x2302             MOVS     R3,#+2
   \   00000048   0x434B             MULS     R3,R1,R3
   \   0000004A   0x5AD2             LDRH     R2,[R2, R3]
   \   0000004C   0x4002             ANDS     R2,R2,R0
   \   0000004E   0x....             LDR      R0,??DataTable8_8
   \   00000050   0x2302             MOVS     R3,#+2
   \   00000052   0x434B             MULS     R3,R1,R3
   \   00000054   0x5AC0             LDRH     R0,[R0, R3]
   \   00000056   0x4282             CMP      R2,R0
   \   00000058   0xD10E             BNE      ??Anttt_is_game_over_4
    130              {
    131                Anttt_away_state = winning_combos[i];
   \   0000005A   0x....             LDR      R0,??DataTable8_8
   \   0000005C   0x2202             MOVS     R2,#+2
   \   0000005E   0x434A             MULS     R2,R1,R2
   \   00000060   0x5A80             LDRH     R0,[R0, R2]
   \   00000062   0x....             LDR      R2,??DataTable8_4
   \   00000064   0x8010             STRH     R0,[R2, #+0]
    132                Anttt_away_state |= 0x200;       // Set this flag to indicate away winning won.
   \   00000066   0x....             LDR      R0,??DataTable8_4
   \   00000068   0x8800             LDRH     R0,[R0, #+0]
   \   0000006A   0x2280             MOVS     R2,#+128
   \   0000006C   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   0000006E   0x4302             ORRS     R2,R2,R0
   \   00000070   0x....             LDR      R0,??DataTable8_4
   \   00000072   0x8002             STRH     R2,[R0, #+0]
    133                
    134                return true;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE00C             B        ??Anttt_is_game_over_3
    135              }
    136            }
   \                     ??Anttt_is_game_over_4: (+1)
   \   00000078   0x1C49             ADDS     R1,R1,#+1
   \   0000007A   0xE7C3             B        ??Anttt_is_game_over_0
    137            
    138            // Check if draw.
    139            if ((Anttt_home_state | Anttt_away_state) == 0x1FF)
   \                     ??Anttt_is_game_over_1: (+1)
   \   0000007C   0x....             LDR      R0,??DataTable8_5
   \   0000007E   0x8800             LDRH     R0,[R0, #+0]
   \   00000080   0x....             LDR      R1,??DataTable8_4
   \   00000082   0x8809             LDRH     R1,[R1, #+0]
   \   00000084   0x4301             ORRS     R1,R1,R0
   \   00000086   0x....             LDR      R0,??DataTable9_2  ;; 0x1ff
   \   00000088   0x4281             CMP      R1,R0
   \   0000008A   0xD101             BNE      ??Anttt_is_game_over_5
    140              return true;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xE000             B        ??Anttt_is_game_over_3
    141            
    142            return false;
   \                     ??Anttt_is_game_over_5: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \                     ??Anttt_is_game_over_3: (+1)
   \   00000092   0xBD00             POP      {PC}             ;; return
    143          }
    144          

   \                                 In section .text, align 2, keep-with-next
    145          static void Anttt_reset_rx_buffer(void)
    146          {
   \                     Anttt_reset_rx_buffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    147            u8 status;
    148            SystemEnterCriticalSection(&status);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       SystemEnterCriticalSection
    149            memset(Anttt_rx_data, 0xFF, ANTTT_COMMAND_SIZE);   // Reset message.
   \   0000000A   0x2503             MOVS     R5,#+3
   \   0000000C   0x24FF             MOVS     R4,#+255
   \   0000000E   0x....             LDR      R6,??DataTable9_1
   \   00000010   0x0022             MOVS     R2,R4
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       __aeabi_memset
    150            SystemExitCriticalSection(status);
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       SystemExitCriticalSection
    151          }
   \   00000022   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    152          
    153          
    154          /*--------------------------------------------------------------------------------------------------------------------*/
    155          /* State Machine definitions                                                                                          */
    156          /*--------------------------------------------------------------------------------------------------------------------*/
    157          /*--------------------------------------------------------------------------------------------------------------------
    158          Function: AntttSM_Idle
    159          */

   \                                 In section .text, align 2, keep-with-next
    160          static void AntttSM_Idle(void)
    161          {
   \                     AntttSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    162            // Check if module is connected to client.
    163            if (G_u32BPEngenuicsFlags == BPENGENUICS_CONNECTED)
   \   00000002   0x....             LDR      R0,??DataTable9_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD107             BNE      ??AntttSM_Idle_0
    164            {
    165              // Set LEDs and proceed to wait state.
    166              LedOn(STATUS_GRN);   // Connected to Client.
   \   0000000A   0x2014             MOVS     R0,#+20
   \   0000000C   0x.... 0x....      BL       LedOn
    167              
    168              // Reset any pending button states incase the user was pressing while waiting.
    169              ButtonInitialize();
   \   00000010   0x.... 0x....      BL       ButtonInitialize
    170              
    171              ANTT_SM = &AntttSM_Wait;
   \   00000014   0x....             LDR      R0,??DataTable9_4
   \   00000016   0x....             LDR      R1,??DataTable8_7
   \   00000018   0x6008             STR      R0,[R1, #+0]
    172            }
    173            // TEST CODE TO TEST BUTTONS
    174            //     for (int button = 0; button < TOTAL_BUTTONS; button++)
    175            //     {
    176            //       if (WasButtonPressed(button))
    177            //       {
    178            //         LedToggle(0xFF);
    179            //         ButtonAcknowledge(button);
    180            //         return;
    181            //       }
    182            //     }
    183          } 
   \                     ??AntttSM_Idle_0: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    184          

   \                                 In section .text, align 2, keep-with-next
    185          static void AntttSM_Wait(void)
    186          {
   \                     AntttSM_Wait: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    187            // Check if module has established connection with client.
    188            if (G_u32BPEngenuicsFlags & BPENGENUICS_CONNECTED)
   \   00000002   0x....             LDR      R0,??DataTable9_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD54B             BPL      ??AntttSM_Wait_0
    189            {
    190              // Wait for Client to make a move.
    191              if (Anttt_rx_data[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE)
   \   0000000A   0x....             LDR      R0,??DataTable8_3
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x28CC             CMP      R0,#+204
   \   00000010   0xD149             BNE      ??AntttSM_Wait_1
    192              {
    193                u8 temp[ANTTT_COMMAND_SIZE];
    194                u8  position = Anttt_rx_data[ANTTT_COMMAND_POSITION_OFFSET];
   \   00000012   0x....             LDR      R0,??DataTable8_3
   \   00000014   0x7844             LDRB     R4,[R0, #+1]
    195                
    196                // Check if position is already chosen or incorrect position sent.
    197                if ((Anttt_home_state & (1 << position)) || (Anttt_away_state & (1 << position))
    198                    || (position >= TOTAL_BUTTONS))
   \   00000016   0x....             LDR      R0,??DataTable8_5
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x40A1             LSLS     R1,R1,R4
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD108             BNE      ??AntttSM_Wait_2
   \   00000022   0x....             LDR      R0,??DataTable8_4
   \   00000024   0x8800             LDRH     R0,[R0, #+0]
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x40A1             LSLS     R1,R1,R4
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD102             BNE      ??AntttSM_Wait_2
   \   0000002E   0xB2E4             UXTB     R4,R4
   \   00000030   0x2C09             CMP      R4,#+9
   \   00000032   0xDB00             BLT      ??AntttSM_Wait_3
    199                {
    200                  return;
   \                     ??AntttSM_Wait_2: (+1)
   \   00000034   0xE049             B        ??AntttSM_Wait_4
    201                }
    202                
    203                // New Position.
    204                LedOn((LedNumberType) (position + 9));  // 9 is the offset for away LEDs.
   \                     ??AntttSM_Wait_3: (+1)
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x3009             ADDS     R0,R0,#+9
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x.... 0x....      BL       LedOn
    205                Anttt_away_state |= 1 << (position);
   \   00000040   0x....             LDR      R0,??DataTable8_4
   \   00000042   0x8800             LDRH     R0,[R0, #+0]
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x40A1             LSLS     R1,R1,R4
   \   00000048   0x4301             ORRS     R1,R1,R0
   \   0000004A   0x....             LDR      R0,??DataTable8_4
   \   0000004C   0x8001             STRH     R1,[R0, #+0]
    206                
    207                // Send response.
    208                temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE_RESP;
   \   0000004E   0x20AC             MOVS     R0,#+172
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    209                BPEngenuicsSendData(temp, ANTTT_COMMAND_SIZE);
   \   00000054   0x2103             MOVS     R1,#+3
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       BPEngenuicsSendData
    210                
    211                // Check if game is over.
    212                if (Anttt_is_game_over())
   \   0000005C   0x.... 0x....      BL       Anttt_is_game_over
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD015             BEQ      ??AntttSM_Wait_5
    213                {
    214                  // Set up initial LEDs.
    215                  LedOff(STATUS_RED);
   \   00000064   0x2012             MOVS     R0,#+18
   \   00000066   0x.... 0x....      BL       LedOff
    216                  LedOff(STATUS_YLW);
   \   0000006A   0x2013             MOVS     R0,#+19
   \   0000006C   0x.... 0x....      BL       LedOff
    217                  LedOff(STATUS_GRN);
   \   00000070   0x2014             MOVS     R0,#+20
   \   00000072   0x.... 0x....      BL       LedOff
    218            
    219                  for (int led = 0; led < TOTAL_BUTTONS * 2; led++)
   \   00000076   0x2500             MOVS     R5,#+0
   \                     ??AntttSM_Wait_6: (+1)
   \   00000078   0x2D12             CMP      R5,#+18
   \   0000007A   0xDA05             BGE      ??AntttSM_Wait_7
    220                    LedOff((LedNumberType) led);
   \   0000007C   0x0028             MOVS     R0,R5
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x.... 0x....      BL       LedOff
   \   00000084   0x1C6D             ADDS     R5,R5,#+1
   \   00000086   0xE7F7             B        ??AntttSM_Wait_6
    221                  
    222                  ANTT_SM = &AntttSM_Gameover;
   \                     ??AntttSM_Wait_7: (+1)
   \   00000088   0x....             LDR      R0,??DataTable10
   \   0000008A   0x....             LDR      R1,??DataTable8_7
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    223                  return;
   \   0000008E   0xE01C             B        ??AntttSM_Wait_4
    224                }
    225                
    226                Anttt_reset_rx_buffer();
   \                     ??AntttSM_Wait_5: (+1)
   \   00000090   0x.... 0x....      BL       Anttt_reset_rx_buffer
    227                
    228                // Update State.
    229                ANTT_SM = &AntttSM_Active;
   \   00000094   0x....             LDR      R0,??DataTable10_1
   \   00000096   0x....             LDR      R1,??DataTable8_7
   \   00000098   0x6008             STR      R0,[R1, #+0]
    230                LedOn(STATUS_YLW);
   \   0000009A   0x2013             MOVS     R0,#+19
   \   0000009C   0x.... 0x....      BL       LedOn
   \   000000A0   0xE001             B        ??AntttSM_Wait_1
    231              }
    232            }
    233            else
    234            {
    235              // Disconnected from client.
    236              AntttInitialize();
   \                     ??AntttSM_Wait_0: (+1)
   \   000000A2   0x.... 0x....      BL       AntttInitialize
    237            }
    238            
    239            // User may be pressing buttons in this state, Ack the button presses to 
    240            // disable queuing of the presses as valid game presses.
    241            for (int button = 0; button < TOTAL_BUTTONS; button++)
   \                     ??AntttSM_Wait_1: (+1)
   \   000000A6   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Wait_8: (+1)
   \   000000A8   0x2C09             CMP      R4,#+9
   \   000000AA   0xDA0E             BGE      ??AntttSM_Wait_9
    242            {
    243              if (WasButtonPressed(button) & !bPendingResponse)
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x.... 0x....      BL       WasButtonPressed
   \   000000B2   0x....             LDR      R1,??DataTable10_2
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0x404A             EORS     R2,R2,R1
   \   000000BA   0xB2C0             UXTB     R0,R0
   \   000000BC   0x4210             TST      R0,R2
   \   000000BE   0xD002             BEQ      ??AntttSM_Wait_10
    244              {
    245                ButtonAcknowledge(button);    // Ack Button Press.
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0x.... 0x....      BL       ButtonAcknowledge
    246              }
    247            }
   \                     ??AntttSM_Wait_10: (+1)
   \   000000C6   0x1C64             ADDS     R4,R4,#+1
   \   000000C8   0xE7EE             B        ??AntttSM_Wait_8
    248          }
   \                     ??AntttSM_Wait_9: (+1)
   \                     ??AntttSM_Wait_4: (+1)
   \   000000CA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    249          

   \                                 In section .text, align 2, keep-with-next
    250          static void AntttSM_Active(void)
    251          {
   \                     AntttSM_Active: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    252            // Check if module has established connection with client.
    253            if (G_u32BPEngenuicsFlags & BPENGENUICS_SERVICEENABLED)
   \   00000004   0x....             LDR      R0,??DataTable9_3
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0780             LSLS     R0,R0,#+30
   \   0000000A   0xD56D             BPL      ??AntttSM_Active_0
    254            {
    255              // Make a move.
    256              // Check if a button was pressed, then update UI and send message.  
    257              for (int button = 0; button < TOTAL_BUTTONS; button++)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Active_1: (+1)
   \   0000000E   0x2C09             CMP      R4,#+9
   \   00000010   0xDA40             BGE      ??AntttSM_Active_2
    258              {
    259                if (WasButtonPressed(button) & !bPendingResponse)
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       WasButtonPressed
   \   00000018   0x....             LDR      R1,??DataTable9
   \   0000001A   0x7809             LDRB     R1,[R1, #+0]
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x404A             EORS     R2,R2,R1
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x4210             TST      R0,R2
   \   00000024   0xD02D             BEQ      ??AntttSM_Active_3
    260                {
    261                  u8 temp[ANTTT_COMMAND_SIZE];
    262                  
    263                  // Check if a valid press. Check if position already chosen via client
    264                  // or itself or incorrect button index reported
    265                  if ((Anttt_home_state & (1 << button)) || (Anttt_away_state & (1 << button))
    266                      || (button >= TOTAL_BUTTONS))
   \   00000026   0x....             LDR      R0,??DataTable10_3
   \   00000028   0x8800             LDRH     R0,[R0, #+0]
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x40A1             LSLS     R1,R1,R4
   \   0000002E   0x4208             TST      R0,R1
   \   00000030   0xD107             BNE      ??AntttSM_Active_4
   \   00000032   0x....             LDR      R0,??DataTable10_4
   \   00000034   0x8800             LDRH     R0,[R0, #+0]
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x40A1             LSLS     R1,R1,R4
   \   0000003A   0x4208             TST      R0,R1
   \   0000003C   0xD101             BNE      ??AntttSM_Active_4
   \   0000003E   0x2C09             CMP      R4,#+9
   \   00000040   0xDB00             BLT      ??AntttSM_Active_5
    267                  {
    268                    continue;
   \                     ??AntttSM_Active_4: (+1)
   \   00000042   0xE025             B        ??AntttSM_Active_6
    269                  }
    270                  
    271                  // Button index directly corresponds to Home LED Index.
    272                  // First Update UI.
    273                  LedOn((LedNumberType) button);
   \                     ??AntttSM_Active_5: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xB2C0             UXTB     R0,R0
   \   00000048   0x.... 0x....      BL       LedOn
    274                  Anttt_home_state |= 1 << (button);
   \   0000004C   0x....             LDR      R0,??DataTable10_3
   \   0000004E   0x8800             LDRH     R0,[R0, #+0]
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x40A1             LSLS     R1,R1,R4
   \   00000054   0x4301             ORRS     R1,R1,R0
   \   00000056   0x....             LDR      R0,??DataTable10_3
   \   00000058   0x8001             STRH     R1,[R0, #+0]
    275                  
    276                  // Send message to client.
    277                  temp[ANTTT_COMMAND_ID_OFFSET] = ANTTT_COMMAND_ID_MOVE;
   \   0000005A   0x20CC             MOVS     R0,#+204
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
    278                  temp[ANTTT_COMMAND_POSITION_OFFSET] = button;
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x7048             STRB     R0,[R1, #+1]
    279                  temp[ANTTT_COMMAND_SOURCE_OFFSET] = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x7088             STRB     R0,[R1, #+2]
    280                  BPEngenuicsSendData(temp, ANTTT_COMMAND_SIZE);
   \   0000006C   0x2103             MOVS     R1,#+3
   \   0000006E   0x4668             MOV      R0,SP
   \   00000070   0x.... 0x....      BL       BPEngenuicsSendData
    281                  
    282                  ButtonAcknowledge(button);    // Ack Button Press.
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       ButtonAcknowledge
    283                  bPendingResponse = true;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x....             LDR      R1,??DataTable9
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
    284                  return;
   \   00000080   0xE034             B        ??AntttSM_Active_7
    285                }
    286                else if (bPendingResponse)
   \                     ??AntttSM_Active_3: (+1)
   \   00000082   0x....             LDR      R0,??DataTable9
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD002             BEQ      ??AntttSM_Active_6
    287                {
    288                  // User may be pressing buttons in this state, Ack the button presses to 
    289                  // disable queuing of the presses as valid game presses.
    290                  ButtonAcknowledge(button);    // Ack Button Press.
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       ButtonAcknowledge
    291                }
    292              }
   \                     ??AntttSM_Active_6: (+1)
   \   00000090   0x1C64             ADDS     R4,R4,#+1
   \   00000092   0xE7BC             B        ??AntttSM_Active_1
    293              
    294              // Check if response received.
    295              if (Anttt_rx_data[ANTTT_COMMAND_ID_OFFSET] == ANTTT_COMMAND_ID_MOVE_RESP)
   \                     ??AntttSM_Active_2: (+1)
   \   00000094   0x....             LDR      R0,??DataTable9_1
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x28AC             CMP      R0,#+172
   \   0000009A   0xD127             BNE      ??AntttSM_Active_8
    296              {
    297                Anttt_reset_rx_buffer();
   \   0000009C   0x.... 0x....      BL       Anttt_reset_rx_buffer
    298                bPendingResponse = false;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x....             LDR      R1,??DataTable9
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    299                
    300                // Check if game is over.
    301                if (Anttt_is_game_over())
   \   000000A6   0x.... 0x....      BL       Anttt_is_game_over
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD015             BEQ      ??AntttSM_Active_9
    302                {
    303                  // Set up initial LEDs.
    304                  LedOff(STATUS_RED);
   \   000000AE   0x2012             MOVS     R0,#+18
   \   000000B0   0x.... 0x....      BL       LedOff
    305                  LedOff(STATUS_YLW);
   \   000000B4   0x2013             MOVS     R0,#+19
   \   000000B6   0x.... 0x....      BL       LedOff
    306                  LedOff(STATUS_GRN);
   \   000000BA   0x2014             MOVS     R0,#+20
   \   000000BC   0x.... 0x....      BL       LedOff
    307            
    308                  for (int led = 0; led < TOTAL_BUTTONS * 2; led++)
   \   000000C0   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Active_10: (+1)
   \   000000C2   0x2C12             CMP      R4,#+18
   \   000000C4   0xDA05             BGE      ??AntttSM_Active_11
    309                    LedOff((LedNumberType) led);
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xB2C0             UXTB     R0,R0
   \   000000CA   0x.... 0x....      BL       LedOff
   \   000000CE   0x1C64             ADDS     R4,R4,#+1
   \   000000D0   0xE7F7             B        ??AntttSM_Active_10
    310                  
    311                  ANTT_SM = &AntttSM_Gameover;
   \                     ??AntttSM_Active_11: (+1)
   \   000000D2   0x....             LDR      R0,??DataTable10
   \   000000D4   0x....             LDR      R1,??DataTable10_5
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    312                  return;
   \   000000D8   0xE008             B        ??AntttSM_Active_7
    313                }
    314                
    315                // Update State.
    316                ANTT_SM = &AntttSM_Wait;
   \                     ??AntttSM_Active_9: (+1)
   \   000000DA   0x....             LDR      R0,??DataTable9_4
   \   000000DC   0x....             LDR      R1,??DataTable10_5
   \   000000DE   0x6008             STR      R0,[R1, #+0]
    317                LedOff(STATUS_YLW);
   \   000000E0   0x2013             MOVS     R0,#+19
   \   000000E2   0x.... 0x....      BL       LedOff
   \   000000E6   0xE001             B        ??AntttSM_Active_8
    318              }
    319            }
    320            else
    321            {
    322              // Disconnected from client.
    323              AntttInitialize();
   \                     ??AntttSM_Active_0: (+1)
   \   000000E8   0x.... 0x....      BL       AntttInitialize
    324            }
    325          }
   \                     ??AntttSM_Active_8: (+1)
   \                     ??AntttSM_Active_7: (+1)
   \   000000EC   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    326          

   \                                 In section .text, align 2, keep-with-next
    327          static void AntttSM_Gameover(void)
    328          {   
   \                     AntttSM_Gameover: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    329            // Play Winning Sequence. 
    330            if ((G_u32SystemTime1ms % 500) == 0)
   \   00000002   0x....             LDR      R0,??DataTable10_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x21FA             MOVS     R1,#+250
   \   00000008   0x0049             LSLS     R1,R1,#+1        ;; #+500
   \   0000000A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD000             BEQ      .+4
   \   00000012   0xE085             B        ??AntttSM_Gameover_0
    331            {
    332              nrf_gpio_pin_toggle(16);
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x.... 0x....      BL       nrf_gpio_pin_toggle
    333              
    334              // Toggle LED sequences.
    335              LedToggle(STATUS_GRN);
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0x.... 0x....      BL       LedToggle
    336              LedToggle(STATUS_RED);
   \   00000020   0x2012             MOVS     R0,#+18
   \   00000022   0x.... 0x....      BL       LedToggle
    337              LedToggle(STATUS_YLW);
   \   00000026   0x2013             MOVS     R0,#+19
   \   00000028   0x.... 0x....      BL       LedToggle
    338              
    339              // Blink winning sequence.
    340              if (Anttt_home_state & 0x200)
   \   0000002C   0x....             LDR      R0,??DataTable10_3
   \   0000002E   0x8800             LDRH     R0,[R0, #+0]
   \   00000030   0x0580             LSLS     R0,R0,#+22
   \   00000032   0xD51D             BPL      ??AntttSM_Gameover_1
    341              {
    342                // Home won.
    343                u8 three[3];
    344                u8 index = 0;
   \   00000034   0x2400             MOVS     R4,#+0
    345                u16 temp = Anttt_home_state;  
   \   00000036   0x....             LDR      R0,??DataTable10_3
   \   00000038   0x8805             LDRH     R5,[R0, #+0]
    346                
    347                // Convert LED bitmask to LED value.
    348                for (int i = 0; i < 9; i++)
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_2: (+1)
   \   0000003C   0x2809             CMP      R0,#+9
   \   0000003E   0xDA0A             BGE      ??AntttSM_Gameover_3
    349                {
    350                  if (temp & 0x01)
   \   00000040   0x07E9             LSLS     R1,R5,#+31
   \   00000042   0xD504             BPL      ??AntttSM_Gameover_4
    351                  {
    352                    three[index++] = i;
   \   00000044   0x0001             MOVS     R1,R0
   \   00000046   0x466A             MOV      R2,SP
   \   00000048   0xB2E4             UXTB     R4,R4
   \   0000004A   0x5511             STRB     R1,[R2, R4]
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
    353                  }
    354                  
    355                  temp = temp >> 1;
   \                     ??AntttSM_Gameover_4: (+1)
   \   0000004E   0xB2AD             UXTH     R5,R5
   \   00000050   0x086D             LSRS     R5,R5,#+1
    356                }
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0xE7F2             B        ??AntttSM_Gameover_2
    357                
    358                LedToggle((LedNumberType)three[0]);
   \                     ??AntttSM_Gameover_3: (+1)
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       LedToggle
    359                LedToggle((LedNumberType)three[1]);
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x7840             LDRB     R0,[R0, #+1]
   \   00000062   0x.... 0x....      BL       LedToggle
    360                LedToggle((LedNumberType)three[2]);
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0x7880             LDRB     R0,[R0, #+2]
   \   0000006A   0x.... 0x....      BL       LedToggle
   \   0000006E   0xE057             B        ??AntttSM_Gameover_0
    361              }
    362              else if (Anttt_away_state & 0x200)
   \                     ??AntttSM_Gameover_1: (+1)
   \   00000070   0x....             LDR      R0,??DataTable10_4
   \   00000072   0x8800             LDRH     R0,[R0, #+0]
   \   00000074   0x0580             LSLS     R0,R0,#+22
   \   00000076   0xD523             BPL      ??AntttSM_Gameover_5
    363              {
    364                // Away won.
    365                u8 three[3];
    366                u8 index = 0;
   \   00000078   0x2400             MOVS     R4,#+0
    367                u16 temp = Anttt_away_state;  
   \   0000007A   0x....             LDR      R0,??DataTable10_4
   \   0000007C   0x8805             LDRH     R5,[R0, #+0]
    368                
    369                // Convert LED bitmask to LED value.
    370                for (int i = 0; i < 9; i++)
   \   0000007E   0x2000             MOVS     R0,#+0
   \                     ??AntttSM_Gameover_6: (+1)
   \   00000080   0x2809             CMP      R0,#+9
   \   00000082   0xDA0A             BGE      ??AntttSM_Gameover_7
    371                {
    372                  if (temp & 0x01)
   \   00000084   0x07E9             LSLS     R1,R5,#+31
   \   00000086   0xD504             BPL      ??AntttSM_Gameover_8
    373                  {
    374                    three[index++] = i;
   \   00000088   0x0001             MOVS     R1,R0
   \   0000008A   0x466A             MOV      R2,SP
   \   0000008C   0xB2E4             UXTB     R4,R4
   \   0000008E   0x5511             STRB     R1,[R2, R4]
   \   00000090   0x1C64             ADDS     R4,R4,#+1
    375                  }
    376                  
    377                  temp = temp >> 1;
   \                     ??AntttSM_Gameover_8: (+1)
   \   00000092   0xB2AD             UXTH     R5,R5
   \   00000094   0x086D             LSRS     R5,R5,#+1
    378                }
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   \   00000098   0xE7F2             B        ??AntttSM_Gameover_6
    379                
    380                LedToggle((LedNumberType)(three[0] + 9));
   \                     ??AntttSM_Gameover_7: (+1)
   \   0000009A   0x4668             MOV      R0,SP
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x3009             ADDS     R0,R0,#+9
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0x.... 0x....      BL       LedToggle
    381                LedToggle((LedNumberType)(three[1] + 9));
   \   000000A6   0x4668             MOV      R0,SP
   \   000000A8   0x7840             LDRB     R0,[R0, #+1]
   \   000000AA   0x3009             ADDS     R0,R0,#+9
   \   000000AC   0xB2C0             UXTB     R0,R0
   \   000000AE   0x.... 0x....      BL       LedToggle
    382                LedToggle((LedNumberType)(three[2] + 9));
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x7880             LDRB     R0,[R0, #+2]
   \   000000B6   0x3009             ADDS     R0,R0,#+9
   \   000000B8   0xB2C0             UXTB     R0,R0
   \   000000BA   0x.... 0x....      BL       LedToggle
   \   000000BE   0xE02F             B        ??AntttSM_Gameover_0
    383              }
    384              else
    385              {
    386                // Play Draw Sequence.
    387                LedToggle((LedNumberType)(0));
   \                     ??AntttSM_Gameover_5: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       LedToggle
    388                LedToggle((LedNumberType)(1));
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       LedToggle
    389                LedToggle((LedNumberType)(2));
   \   000000CC   0x2002             MOVS     R0,#+2
   \   000000CE   0x.... 0x....      BL       LedToggle
    390                LedToggle((LedNumberType)(3));
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x.... 0x....      BL       LedToggle
    391                LedToggle((LedNumberType)(5));
   \   000000D8   0x2005             MOVS     R0,#+5
   \   000000DA   0x.... 0x....      BL       LedToggle
    392                LedToggle((LedNumberType)(6));
   \   000000DE   0x2006             MOVS     R0,#+6
   \   000000E0   0x.... 0x....      BL       LedToggle
    393                LedToggle((LedNumberType)(7));
   \   000000E4   0x2007             MOVS     R0,#+7
   \   000000E6   0x.... 0x....      BL       LedToggle
    394                LedToggle((LedNumberType)(8));
   \   000000EA   0x2008             MOVS     R0,#+8
   \   000000EC   0x.... 0x....      BL       LedToggle
    395                LedToggle((LedNumberType)(0 + 9));
   \   000000F0   0x2009             MOVS     R0,#+9
   \   000000F2   0x.... 0x....      BL       LedToggle
    396                LedToggle((LedNumberType)(1 + 9));
   \   000000F6   0x200A             MOVS     R0,#+10
   \   000000F8   0x.... 0x....      BL       LedToggle
    397                LedToggle((LedNumberType)(2 + 9));
   \   000000FC   0x200B             MOVS     R0,#+11
   \   000000FE   0x.... 0x....      BL       LedToggle
    398                LedToggle((LedNumberType)(3 + 9));
   \   00000102   0x200C             MOVS     R0,#+12
   \   00000104   0x.... 0x....      BL       LedToggle
    399                LedToggle((LedNumberType)(5 + 9));
   \   00000108   0x200E             MOVS     R0,#+14
   \   0000010A   0x.... 0x....      BL       LedToggle
    400                LedToggle((LedNumberType)(6 + 9));
   \   0000010E   0x200F             MOVS     R0,#+15
   \   00000110   0x.... 0x....      BL       LedToggle
    401                LedToggle((LedNumberType)(7 + 9));
   \   00000114   0x2010             MOVS     R0,#+16
   \   00000116   0x.... 0x....      BL       LedToggle
    402                LedToggle((LedNumberType)(8 + 9));
   \   0000011A   0x2011             MOVS     R0,#+17
   \   0000011C   0x.... 0x....      BL       LedToggle
    403              }
    404            }
    405            
    406            // Check if any button was pressed and return to initialized state.
    407            for (int button = 0; button < TOTAL_BUTTONS; button++)
   \                     ??AntttSM_Gameover_0: (+1)
   \   00000120   0x2400             MOVS     R4,#+0
   \                     ??AntttSM_Gameover_9: (+1)
   \   00000122   0x2C09             CMP      R4,#+9
   \   00000124   0xDA0C             BGE      ??AntttSM_Gameover_10
    408            {
    409              if (WasButtonPressed(button))
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       WasButtonPressed
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD005             BEQ      ??AntttSM_Gameover_11
    410              {
    411                AntttInitialize();
   \   00000130   0x.... 0x....      BL       AntttInitialize
    412                ButtonAcknowledge(button);
   \   00000134   0x0020             MOVS     R0,R4
   \   00000136   0x.... 0x....      BL       ButtonAcknowledge
    413                return;
   \   0000013A   0xE001             B        ??AntttSM_Gameover_12
    414              }
    415            }
   \                     ??AntttSM_Gameover_11: (+1)
   \   0000013C   0x1C64             ADDS     R4,R4,#+1
   \   0000013E   0xE7F0             B        ??AntttSM_Gameover_9
    416          }
   \                     ??AntttSM_Gameover_10: (+1)
   \                     ??AntttSM_Gameover_12: (+1)
   \   00000140   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x5000050C         DC32     0x5000050c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x50000504         DC32     0x50000504

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x50000508         DC32     0x50000508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     Anttt_rx_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     Anttt_away_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     Anttt_home_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     AntttSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     ANTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     winning_combos

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     bPendingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     Anttt_rx_data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     G_u32BPEngenuicsFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     AntttSM_Wait

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     AntttSM_Gameover

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     AntttSM_Active

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     bPendingResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     Anttt_home_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     Anttt_away_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     ANTT_SM

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     G_u32SystemTime1ms
    417          /*--------------------------------------------------------------------------------------------------------------------*/
    418          /* End of File                                                                                                        */
    419          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AntttHandleIncomingMessage
        16   -> __aeabi_memcpy
      16   AntttIncomingMessage
        16   -> __aeabi_memcpy
       8   AntttInitialize
         8   -> Anttt_reset_rx_buffer
         8   -> LedOff
         8   -> LedOn
         8   -> nrf_gpio_pin_clear
      16   AntttSM_Active
        16   -> AntttInitialize
        16   -> Anttt_is_game_over
        16   -> Anttt_reset_rx_buffer
        16   -> BPEngenuicsSendData
        16   -> ButtonAcknowledge
        16   -> LedOff
        16   -> LedOn
        16   -> WasButtonPressed
      16   AntttSM_Gameover
        16   -> AntttInitialize
        16   -> ButtonAcknowledge
        16   -> LedToggle
        16   -> WasButtonPressed
        16   -> nrf_gpio_pin_toggle
        16 __aeabi_uidivmod
       8   AntttSM_Idle
         8   -> ButtonInitialize
         8   -> LedOn
      16   AntttSM_Wait
        16   -> AntttInitialize
        16   -> Anttt_is_game_over
        16   -> Anttt_reset_rx_buffer
        16   -> BPEngenuicsSendData
        16   -> ButtonAcknowledge
        16   -> LedOff
        16   -> LedOn
        16   -> WasButtonPressed
       4   Anttt_is_game_over
      24   Anttt_reset_rx_buffer
        24   -> SystemEnterCriticalSection
        24   -> SystemExitCriticalSection
        24   -> __aeabi_memset
       0   nrf_gpio_pin_clear
       4   nrf_gpio_pin_toggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ANTT_SM
      28  AntttHandleIncomingMessage
      28  AntttIncomingMessage
      76  AntttInitialize
     238  AntttSM_Active
     322  AntttSM_Gameover
      28  AntttSM_Idle
     204  AntttSM_Wait
       2  Anttt_away_state
       2  Anttt_home_state
     148  Anttt_is_game_over
      36  Anttt_reset_rx_buffer
       4  Anttt_rx_data
       4  G_u32AntttFlags
       1  bPendingResponse
      10  nrf_gpio_pin_clear
      34  nrf_gpio_pin_toggle
      16  winning_combos

 
    17 bytes in section .bss
    16 bytes in section .data
 1 236 bytes in section .text
 
 1 236 bytes of CODE memory
    33 bytes of DATA memory

Errors: none
Warnings: 2
