###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.2.13589/W32 for ARM       31/Dec/2017  12:56:28
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\Vipin\Documents\GitHub\ANTTT\drivers\buttons.c
#    Command line =  
#        -f C:\Users\Vipin\AppData\Local\Temp\EWC69B.tmp
#        (C:\Users\Vipin\Documents\GitHub\ANTTT\drivers\buttons.c -D NRF51 -lC
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\List -o
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M0 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\bsp\ -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\application\ -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\s310\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\ble_services\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\ble\device_manager\
#        -I
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\nordic_sdk6_1_0\Include\app_common\
#        -I C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\..\drivers\ -On -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\List\buttons.lst
#    Object file  =  
#        C:\Users\Vipin\Documents\GitHub\ANTTT\iar_7_20_1\Debug\Obj\buttons.o
#
###############################################################################

C:\Users\Vipin\Documents\GitHub\ANTTT\drivers\buttons.c
      1          /***********************************************************************************************************************
      2          File: buttons.c                                                                
      3          
      4          Description:
      5          Button functions and state machine.  The application handles all debouncing and glitch filtering.
      6          
      7          ------------------------------------------------------------------------------------------------------------------------
      8          API:
      9          Types:
     10          MPG1: The argument u32Button_ is either BUTTON0, BUTTON1, BUTTON2, or BUTTON3.  
     11          MPG1: The argument u32Button_ is either BUTTON0 or BUTTON1.  
     12          
     13          Public:
     14          bool IsButtonPressed(u32 u32Button_)
     15          Returns true if a particular button is currently pressed (and debounced).
     16          
     17          bool WasButtonPressed(u32 u32Button_)
     18          Returns true if a particular button was pressed since last time it was checked even if it is no longer pressed.
     19          ButtonAcknowledge is typically called immediately after WasButtonPressed() returns true to clear the button
     20          pressed state.
     21          
     22          void ButtonAcknowledge(u32 u32Button_)
     23          Clears the New Press state of a button -- generally always called after WasButtonPressed() returns true.
     24          
     25          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
     26          Returns true if a button has been held for u32ButtonHeldTime_ time in milliseconds.
     27          
     28          Protected:
     29          void ButtonInitialize(void)
     30          Configures the button system for the product including enabling button GPIO interrupts.  
     31          
     32          u32 GetButtonBitLocation(u8 u8Button_, ButtonPortType ePort_)
     33          Returns the location of the button within its port (should be required only for interrupt service routines).  
     34          
     35          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     36          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     37          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     38          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     39          
     40          ***********************************************************************************************************************/
     41          
     42          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_set(uint32_t)
   \                     nrf_gpio_pin_set: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable12  ;; 0x50000508
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpio_pin_clear(uint32_t)
   \                     nrf_gpio_pin_clear: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4081             LSLS     R1,R1,R0
   \   00000004   0x....             LDR      R2,??DataTable12_1  ;; 0x5000050c
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t nrf_gpio_pin_read(uint32_t)
   \                     nrf_gpio_pin_read: (+1)
   \   00000000   0x....             LDR      R1,??DataTable12_2  ;; 0x50000510
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x40C1             LSRS     R1,R1,R0
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0x07C0             LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
   \   0000000A   0x0FC0             LSRS     R0,R0,#+31
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void nrf_gpiote_event_config(uint32_t, uint32_t, enum <unnamed>#54)
   \                     nrf_gpiote_event_config: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x020B             LSLS     R3,R1,#+8
   \   00000004   0xB2D2             UXTB     R2,R2
   \   00000006   0x0414             LSLS     R4,R2,#+16
   \   00000008   0x431C             ORRS     R4,R4,R3
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x4323             ORRS     R3,R3,R4
   \   0000000E   0x....             LDR      R4,??DataTable12_3  ;; 0x40006510
   \   00000010   0x2504             MOVS     R5,#+4
   \   00000012   0x4345             MULS     R5,R0,R5
   \   00000014   0x5163             STR      R3,[R4, R5]
   \   00000016   0xBF00             Nop      
   \   00000018   0xBF00             Nop      
   \   0000001A   0xBF00             Nop      
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x....             LDR      R4,??DataTable13  ;; 0x40006100
   \   00000020   0x2504             MOVS     R5,#+4
   \   00000022   0x4345             MULS     R5,R0,R5
   \   00000024   0x5163             STR      R3,[R4, R5]
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
     43          
     44          /***********************************************************************************************************************
     45          Global variable definitions with scope across entire project.
     46          All Global variable names shall start with "G_<type>Button"
     47          ***********************************************************************************************************************/
     48          /* New variables */

   \                                 In section .bss, align 4
     49          volatile bool G_abButtonDebounceActive[TOTAL_BUTTONS];           /* Flags for buttons being debounced */
   \                     G_abButtonDebounceActive:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     50          volatile u32 G_au32ButtonDebounceTimeStart[TOTAL_BUTTONS];       /* Button debounce start time */
   \                     G_au32ButtonDebounceTimeStart:
   \   00000000                      DS8 36
     51          
     52          /*--------------------------------------------------------------------------------------------------------------------*/
     53          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     54          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     55          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     56          
     57          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     58          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     59          
     60          
     61          /***********************************************************************************************************************
     62          Global variable definitions with scope limited to this local application.
     63          Variable names shall start with "Button_" and be declared as static.
     64          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     65          static fnCode_type Button_pfnStateMachine;                  /* The Button application state machine function pointer */
   \                     Button_pfnStateMachine:
   \   00000000                      DS8 4
     66          

   \                                 In section .bss, align 4
     67          static ButtonStateType Button_aeCurrentState[TOTAL_BUTTONS];/* Current pressed state of button */
   \                     Button_aeCurrentState:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     68          static ButtonStateType Button_aeNewState[TOTAL_BUTTONS];    /* New (pending) pressed state of button */
   \                     Button_aeNewState:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     69          static u32 Button_au32HoldTimeStart[TOTAL_BUTTONS];         /* System 1ms time when a button press started */
   \                     Button_au32HoldTimeStart:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     70          static bool Button_abNewPress[TOTAL_BUTTONS];               /* Flags to indicate a button was pressed */    
   \                     Button_abNewPress:
   \   00000000                      DS8 12

   \                                 In section .bss, align 1
     71          static u8 u8ActiveCol;                                      /* Current Active Button Column */                                                                                    
   \                     u8ActiveCol:
   \   00000000                      DS8 1
     72          
     73          
     74          /***********************************************************************************************************************
     75          Function Definitions
     76          ***********************************************************************************************************************/
     77          /*--------------------------------------------------------------------------------------------------------------------*/
     78          /* Public Functions */
     79          /*--------------------------------------------------------------------------------------------------------------------*/
     80          
     81          /*----------------------------------------------------------------------------------------------------------------------
     82          Function: IsButtonPressed
     83          
     84          Description:
     85          Determine if a particular button is currently pressed at this moment in time.
     86          The button must still be pressed at the time of this inquiry for the function
     87          to return true.
     88          
     89          Requires:
     90            - u32Button_ is a valid button index
     91            - Button_aeCurrentState[u32Button_] is a valid index
     92           
     93          Promises:
     94            - Returns true if Button_aeCurrentState[u32Button_] is pressed; otherwise returns false
     95          */

   \                                 In section .text, align 2, keep-with-next
     96          bool IsButtonPressed(u32 u32Button_)
     97          {
   \                     IsButtonPressed: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     98            if( Button_aeCurrentState[u32Button_] == PRESSED)
   \   00000004   0x....             LDR      R0,??DataTable13_1
   \   00000006   0x5C40             LDRB     R0,[R0, R1]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE      ??IsButtonPressed_0
     99            {
    100              return(true);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B        ??IsButtonPressed_1
    101            }
    102            else
    103            {
    104              return(false);
   \                     ??IsButtonPressed_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??IsButtonPressed_1: (+1)
   \   00000012   0xBD00             POP      {PC}             ;; return
    105            }
    106          
    107          } /* end IsButtonPressed() */
    108          
    109          
    110          /*----------------------------------------------------------------------------------------------------------------------
    111          Function: WasButtonPressed
    112          
    113          Description:
    114          Determines if a particular button was pressed since last time it was checked. 
    115          The button may or may not still be pressed when this inquiry is made.  Mulitple
    116          button presses are not tracked.  The user should call ButtonAcknowledge immediately
    117          following this function to clear the state.
    118          
    119          Requires:
    120            - u32 u32Button_ is a valid button index
    121            - Button_aeCurrentState[u32Button_] is valid
    122           
    123          Promises:
    124            - Returns true if Button_abNewPress[u32Button_] is true; other wise returns false
    125          */

   \                                 In section .text, align 2, keep-with-next
    126          bool WasButtonPressed(u32 u32Button_)
    127          {
   \                     WasButtonPressed: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    128            if( Button_abNewPress[u32Button_] == true)
   \   00000004   0x....             LDR      R0,??DataTable13_2
   \   00000006   0x5C40             LDRB     R0,[R0, R1]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE      ??WasButtonPressed_0
    129            {
    130              return(true);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B        ??WasButtonPressed_1
    131            }
    132            else
    133            {
    134              return(false);
   \                     ??WasButtonPressed_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??WasButtonPressed_1: (+1)
   \   00000012   0xBD00             POP      {PC}             ;; return
    135            }
    136          
    137          } /* end WasButtonPressed() */
    138          
    139          
    140          /*----------------------------------------------------------------------------------------------------------------------
    141          Function: ButtonAcknowledge
    142          
    143          Description:
    144          Clears the New Press state of a button.
    145          
    146          Requires:
    147            - u32Button_ is a valid button index
    148           
    149          Promises:
    150            - The flag at Button_abNewPress[u32Button_] is set to false
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          void ButtonAcknowledge(u32 u32Button_)
    153          {
    154            Button_abNewPress[u32Button_] = false;
   \                     ButtonAcknowledge: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR      R2,??DataTable13_2
   \   00000004   0x5411             STRB     R1,[R2, R0]
    155          
    156          } /* end ButtonAcknowledge() */
   \   00000006   0x4770             BX       LR               ;; return
    157          
    158          
    159          /*----------------------------------------------------------------------------------------------------------------------
    160          Function: IsButtonHeld
    161          
    162          Description:
    163          Queries to see if a button has been held for a certain time.  The button
    164          must still be pressed when this function is called if it is to return true.
    165          
    166          Requires:
    167            - u32Button_ is a valid button index
    168            - u32ButtonHeldTime is a time in ms 
    169           
    170          Promises:
    171            - Returns true if eButton_ has been held longer than u32ButtonHeldTime_
    172          */

   \                                 In section .text, align 2, keep-with-next
    173          bool IsButtonHeld(u32 u32Button_, u32 u32ButtonHeldTime_)
    174          {
   \                     IsButtonHeld: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    175           if( IsButtonPressed(u32Button_) && 
    176               IsTimeUp(&Button_au32HoldTimeStart[u32Button_], u32ButtonHeldTime_ ) )
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       IsButtonPressed
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00A             BEQ      ??IsButtonHeld_0
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0x....             LDR      R0,??DataTable13_3
   \   00000014   0x2204             MOVS     R2,#+4
   \   00000016   0x436A             MULS     R2,R5,R2
   \   00000018   0x1880             ADDS     R0,R0,R2
   \   0000001A   0x.... 0x....      BL       IsTimeUp
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ      ??IsButtonHeld_0
    177           {
    178             return(true);
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B        ??IsButtonHeld_1
    179           }
    180           else
    181           {
    182             return(false);
   \                     ??IsButtonHeld_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??IsButtonHeld_1: (+1)
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    183           }
    184          
    185          } /* end IsButtonHeld() */
    186          
    187          
    188          /*--------------------------------------------------------------------------------------------------------------------*/
    189          /* Protected Functions */
    190          /*--------------------------------------------------------------------------------------------------------------------*/
    191          
    192          /*----------------------------------------------------------------------------------------------------------------------
    193          Function: ButtonInitialize
    194          
    195          Description:
    196          Configures the button system for the product including enabling button GPIO interrupts.  
    197          
    198          Requires:
    199            - GPIO configuration is already complete for all button inputs
    200            - Button interrupt initializations and handler functions are ready
    201           
    202          Promises:
    203            - G_abButtonDebounceActive, LGaeButtonPreviousState and Button_aeCurrentState 
    204              are intialized
    205            - GGstButtonTrackballPosition fields are all initialized to default values
    206            - The button state machine is initialized to Idle
    207          */

   \                                 In section .text, align 2, keep-with-next
    208          void ButtonInitialize(void)
    209          {
   \                     ButtonInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    210            u8ActiveCol = 0;      // Set initial active col.
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR      R1,??DataTable13_4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    211            
    212            /* Setup default data for all of the buttons in the system */
    213            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \                     ??ButtonInitialize_0: (+1)
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x2809             CMP      R0,#+9
   \   0000000E   0xDA0D             BGE      ??ButtonInitialize_1
    214            {
    215              G_abButtonDebounceActive[i] = false;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR      R2,??DataTable13_5
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x5411             STRB     R1,[R2, R0]
    216              Button_aeCurrentState[i]    = RELEASED;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x....             LDR      R2,??DataTable13_1
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x5411             STRB     R1,[R2, R0]
    217              Button_aeNewState[i]        = RELEASED;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x....             LDR      R2,??DataTable13_6
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x5411             STRB     R1,[R2, R0]
    218            }
   \   00000028   0x1C40             ADDS     R0,R0,#+1
   \   0000002A   0xE7EE             B        ??ButtonInitialize_0
    219            
    220            // Initialize BUTTON_COLS to initial state.
    221            nrf_gpio_pin_set(BUTTON_COL1_PIN);    // Disabled Column (ACTIVE LOW)
   \                     ??ButtonInitialize_1: (+1)
   \   0000002C   0x200E             MOVS     R0,#+14
   \   0000002E   0x.... 0x....      BL       nrf_gpio_pin_set
    222            nrf_gpio_pin_set(BUTTON_COL2_PIN);    // Disabled Column
   \   00000032   0x200F             MOVS     R0,#+15
   \   00000034   0x.... 0x....      BL       nrf_gpio_pin_set
    223            nrf_gpio_pin_set(BUTTON_COL3_PIN);    // Disabled Column
   \   00000038   0x2017             MOVS     R0,#+23
   \   0000003A   0x.... 0x....      BL       nrf_gpio_pin_set
    224            
    225            // Enable Interrupts.
    226            nrf_gpiote_event_config(BUTTON_ROW1_GPIOTE_CHANNEL, BUTTON_ROW1_PIN, NRF_GPIOTE_POLARITY_TOGGLE);
   \   0000003E   0x2203             MOVS     R2,#+3
   \   00000040   0x211A             MOVS     R1,#+26
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       nrf_gpiote_event_config
    227            nrf_gpiote_event_config(BUTTON_ROW2_GPIOTE_CHANNEL, BUTTON_ROW2_PIN, NRF_GPIOTE_POLARITY_TOGGLE);
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0x2108             MOVS     R1,#+8
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x.... 0x....      BL       nrf_gpiote_event_config
    228            nrf_gpiote_event_config(BUTTON_ROW3_GPIOTE_CHANNEL, BUTTON_ROW3_PIN, NRF_GPIOTE_POLARITY_TOGGLE);
   \   00000052   0x2203             MOVS     R2,#+3
   \   00000054   0x2109             MOVS     R1,#+9
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x.... 0x....      BL       nrf_gpiote_event_config
    229            NRF_GPIOTE->INTENSET = (GPIOTE_INTENSET_IN0_Msk | GPIOTE_INTENSET_IN1_Msk | GPIOTE_INTENSET_IN2_Msk);  
   \   0000005C   0x2007             MOVS     R0,#+7
   \   0000005E   0x....             LDR      R1,??DataTable13_7  ;; 0x40006304
   \   00000060   0x6008             STR      R0,[R1, #+0]
    230            
    231            /* Init complete: set function pointer and application flag */
    232            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000062   0x....             LDR      R0,??DataTable13_8
   \   00000064   0x....             LDR      R1,??DataTable13_9
   \   00000066   0x6008             STR      R0,[R1, #+0]
    233           } /* end ButtonInitialize() */
   \   00000068   0xBD01             POP      {R0,PC}          ;; return
    234          
    235          
    236          /*----------------------------------------------------------------------------------------------------------------------
    237          Function ButtonRunActiveState()
    238          
    239          Description:
    240          Selects and runs one iteration of the current state in the state machine.
    241          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    242          may take 1ms / n to execute.
    243          
    244          Requires:
    245            - State machine function pointer points at current state
    246          
    247          Promises:
    248            - Calls the function to pointed by the state machine function pointer
    249          */

   \                                 In section .text, align 2, keep-with-next
    250          void ButtonRunActiveState(void)
    251          {
   \                     ButtonRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    252            Button_pfnStateMachine();
   \   00000002   0x....             LDR      R0,??DataTable13_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    253          
    254          } /* end ButtonRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    255          
    256          

   \                                 In section .text, align 2, keep-with-next
    257          u8 Button_get_active_column(void)
    258          {
    259             return u8ActiveCol;
   \                     Button_get_active_column: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13_4
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    260          }
    261          
    262          
    263          /*--------------------------------------------------------------------------------------------------------------------*/
    264          /* Private functions */
    265          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    266          static void Button_rotate_columns(void)
    267          {
   \                     Button_rotate_columns: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    268             if (G_u32SystemTime1ms % BUTTON_COLUMN_SWITCH_TIME_MS)
   \   00000002   0x....             LDR      R0,??DataTable13_10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x210A             MOVS     R1,#+10
   \   00000008   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD031             BEQ      ??Button_rotate_columns_0
    269             {
    270               u8ActiveCol++;
   \   00000010   0x....             LDR      R0,??DataTable13_4
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x....             LDR      R1,??DataTable13_4
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    271               if (u8ActiveCol >= 3)
   \   0000001A   0x....             LDR      R0,??DataTable13_4
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xDB02             BLT      ??Button_rotate_columns_1
    272                 u8ActiveCol = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable13_4
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    273               
    274               switch (u8ActiveCol)
   \                     ??Button_rotate_columns_1: (+1)
   \   00000028   0x....             LDR      R0,??DataTable13_4
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ      ??Button_rotate_columns_2
   \   00000030   0x2802             CMP      R0,#+2
   \   00000032   0xD015             BEQ      ??Button_rotate_columns_3
   \   00000034   0xD30A             BCC      ??Button_rotate_columns_4
   \   00000036   0xE01D             B        ??Button_rotate_columns_5
    275               {
    276                  case 0:
    277                    nrf_gpio_pin_clear(BUTTON_COL1_PIN);
   \                     ??Button_rotate_columns_2: (+1)
   \   00000038   0x200E             MOVS     R0,#+14
   \   0000003A   0x.... 0x....      BL       nrf_gpio_pin_clear
    278                    nrf_gpio_pin_set(BUTTON_COL2_PIN);
   \   0000003E   0x200F             MOVS     R0,#+15
   \   00000040   0x.... 0x....      BL       nrf_gpio_pin_set
    279                    nrf_gpio_pin_set(BUTTON_COL3_PIN);
   \   00000044   0x2017             MOVS     R0,#+23
   \   00000046   0x.... 0x....      BL       nrf_gpio_pin_set
    280                    break;
   \   0000004A   0xE013             B        ??Button_rotate_columns_0
    281                  case 1:
    282                    nrf_gpio_pin_clear(BUTTON_COL2_PIN);
   \                     ??Button_rotate_columns_4: (+1)
   \   0000004C   0x200F             MOVS     R0,#+15
   \   0000004E   0x.... 0x....      BL       nrf_gpio_pin_clear
    283                    nrf_gpio_pin_set(BUTTON_COL1_PIN);
   \   00000052   0x200E             MOVS     R0,#+14
   \   00000054   0x.... 0x....      BL       nrf_gpio_pin_set
    284                    nrf_gpio_pin_set(BUTTON_COL3_PIN);
   \   00000058   0x2017             MOVS     R0,#+23
   \   0000005A   0x.... 0x....      BL       nrf_gpio_pin_set
    285                    break;
   \   0000005E   0xE009             B        ??Button_rotate_columns_0
    286                  case 2:
    287                    nrf_gpio_pin_clear(BUTTON_COL3_PIN);
   \                     ??Button_rotate_columns_3: (+1)
   \   00000060   0x2017             MOVS     R0,#+23
   \   00000062   0x.... 0x....      BL       nrf_gpio_pin_clear
    288                    nrf_gpio_pin_set(BUTTON_COL1_PIN);
   \   00000066   0x200E             MOVS     R0,#+14
   \   00000068   0x.... 0x....      BL       nrf_gpio_pin_set
    289                    nrf_gpio_pin_set(BUTTON_COL2_PIN);
   \   0000006C   0x200F             MOVS     R0,#+15
   \   0000006E   0x.... 0x....      BL       nrf_gpio_pin_set
    290                    break;
   \   00000072   0xE7FF             B        ??Button_rotate_columns_0
    291                  default:
    292                    break;
    293               }
    294             }
    295          }
   \                     ??Button_rotate_columns_5: (+1)
   \                     ??Button_rotate_columns_0: (+1)
   \   00000074   0xBD01             POP      {R0,PC}          ;; return
    296          

   \                                 In section .text, align 2, keep-with-next
    297          static bool Button_is_still_pressed(u8 button)
    298          {
   \                     Button_is_still_pressed: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    299             u8 row = (button - Button_get_active_column()) / 3;   // Row corresponding 
   \   00000004   0xB2E4             UXTB     R4,R4
   \   00000006   0x.... 0x....      BL       Button_get_active_column
   \   0000000A   0x1A20             SUBS     R0,R4,R0
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0x.... 0x....      BL       __aeabi_idiv
   \   00000012   0x0005             MOVS     R5,R0
    300          
    301             // Map Row Index to Pin and check if pin is low (active low)
    302             if (row == 0)
   \   00000014   0xB2ED             UXTB     R5,R5
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD109             BNE      ??Button_is_still_pressed_0
    303                return (nrf_gpio_pin_read(BUTTON_ROW1_PIN) == 0);
   \   0000001A   0x201A             MOVS     R0,#+26
   \   0000001C   0x.... 0x....      BL       nrf_gpio_pin_read
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD101             BNE      ??Button_is_still_pressed_1
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B        ??Button_is_still_pressed_2
   \                     ??Button_is_still_pressed_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??Button_is_still_pressed_2: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0xE01A             B        ??Button_is_still_pressed_3
    304             else if (row == 1)
   \                     ??Button_is_still_pressed_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD109             BNE      ??Button_is_still_pressed_4
    305                return (nrf_gpio_pin_read(BUTTON_ROW2_PIN) == 0);
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x.... 0x....      BL       nrf_gpio_pin_read
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD101             BNE      ??Button_is_still_pressed_5
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE000             B        ??Button_is_still_pressed_6
   \                     ??Button_is_still_pressed_5: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??Button_is_still_pressed_6: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0xE00D             B        ??Button_is_still_pressed_3
    306             else if (row == 2)
   \                     ??Button_is_still_pressed_4: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5
   \   0000004A   0x2D02             CMP      R5,#+2
   \   0000004C   0xD109             BNE      ??Button_is_still_pressed_7
    307                return (nrf_gpio_pin_read(BUTTON_ROW3_PIN) == 0);
   \   0000004E   0x2009             MOVS     R0,#+9
   \   00000050   0x.... 0x....      BL       nrf_gpio_pin_read
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD101             BNE      ??Button_is_still_pressed_8
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xE000             B        ??Button_is_still_pressed_9
   \                     ??Button_is_still_pressed_8: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??Button_is_still_pressed_9: (+1)
   \   0000005E   0xB2C0             UXTB     R0,R0
   \   00000060   0xE000             B        ??Button_is_still_pressed_3
    308          
    309             return false;
   \                     ??Button_is_still_pressed_7: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??Button_is_still_pressed_3: (+1)
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    310          }
    311          
    312          
    313          /***********************************************************************************************************************
    314          State Machine Function Definitions
    315          
    316          The button state machine monitors button activity and manages debouncing and
    317          maintaining the global button states.
    318          ***********************************************************************************************************************/
    319          
    320          /*--------------------------------------------------------------------------------------------------------------------*/
    321          /* Do nothing but wait for a debounce time to start */

   \                                 In section .text, align 2, keep-with-next
    322          static void ButtonSM_Idle(void)                
    323          {
   \                     ButtonSM_Idle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    324            bool is_any_button_debouncing = false;
   \   00000004   0x2400             MOVS     R4,#+0
    325            
    326            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000006   0x2000             MOVS     R0,#+0
   \                     ??ButtonSM_Idle_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x2809             CMP      R0,#+9
   \   0000000C   0xDA0B             BGE      ??ButtonSM_Idle_1
    327            {
    328              if(G_abButtonDebounceActive[i])
   \   0000000E   0x....             LDR      R1,??DataTable13_5
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x5C09             LDRB     R1,[R1, R0]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD004             BEQ      ??ButtonSM_Idle_2
    329              {
    330                is_any_button_debouncing = true;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x000C             MOVS     R4,R1
    331                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   0000001C   0x....             LDR      R1,??DataTable13_11
   \   0000001E   0x....             LDR      R2,??DataTable13_9
   \   00000020   0x6011             STR      R1,[R2, #+0]
    332              }
    333            }
   \                     ??ButtonSM_Idle_2: (+1)
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xE7F0             B        ??ButtonSM_Idle_0
    334             
    335            // Check that no button is debouncing.
    336            if (!is_any_button_debouncing)
   \                     ??ButtonSM_Idle_1: (+1)
   \   00000026   0xB2E4             UXTB     R4,R4
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD108             BNE      ??ButtonSM_Idle_3
    337            {
    338               u8 status;
    339               SystemEnterCriticalSection(&status);
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x.... 0x....      BL       SystemEnterCriticalSection
    340               Button_rotate_columns();
   \   00000032   0x.... 0x....      BL       Button_rotate_columns
    341               SystemExitCriticalSection(status);  
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       SystemExitCriticalSection
    342            }
    343          } /* end ButtonSM_Idle(void) */
   \                     ??ButtonSM_Idle_3: (+1)
   \   0000003E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    344          
    345          
    346          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    347          static void ButtonSM_ButtonActive(void)         
    348          {
   \                     ButtonSM_ButtonActive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    349            /* Start by resseting back to Idle in case no buttons are active */
    350            Button_pfnStateMachine = ButtonSM_Idle;
   \   00000002   0x....             LDR      R0,??DataTable13_8
   \   00000004   0x....             LDR      R1,??DataTable13_9
   \   00000006   0x6008             STR      R0,[R1, #+0]
    351          
    352            /* Check for buttons that are debouncing */
    353            for(u8 i = 0; i < TOTAL_BUTTONS; i++)
   \   00000008   0x2400             MOVS     R4,#+0
   \                     ??ButtonSM_ButtonActive_0: (+1)
   \   0000000A   0xB2E4             UXTB     R4,R4
   \   0000000C   0x2C09             CMP      R4,#+9
   \   0000000E   0xDA47             BGE      ??ButtonSM_ButtonActive_1
    354            {
    355              if(G_abButtonDebounceActive[i] )
   \   00000010   0x....             LDR      R0,??DataTable13_5
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x5D00             LDRB     R0,[R0, R4]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD040             BEQ      ??ButtonSM_ButtonActive_2
    356              {
    357                /* Still have an active button */
    358                Button_pfnStateMachine = ButtonSM_ButtonActive;
   \   0000001A   0x....             LDR      R0,??DataTable13_11
   \   0000001C   0x....             LDR      R1,??DataTable13_9
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    359                
    360                if( IsTimeUp((u32*)&G_au32ButtonDebounceTimeStart[i], BUTTON_DEBOUNCE_TIME) )
   \   00000020   0x2119             MOVS     R1,#+25
   \   00000022   0x....             LDR      R0,??DataTable13_12
   \   00000024   0xB2E4             UXTB     R4,R4
   \   00000026   0x2204             MOVS     R2,#+4
   \   00000028   0x4362             MULS     R2,R4,R2
   \   0000002A   0x1880             ADDS     R0,R0,R2
   \   0000002C   0x.... 0x....      BL       IsTimeUp
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD033             BEQ      ??ButtonSM_ButtonActive_2
    361                {
    362                   if(Button_is_still_pressed(i))
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x.... 0x....      BL       Button_is_still_pressed
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD004             BEQ      ??ButtonSM_ButtonActive_3
    363                   {
    364                      Button_aeNewState[i] = PRESSED;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR      R1,??DataTable13_6
   \   00000044   0xB2E4             UXTB     R4,R4
   \   00000046   0x5508             STRB     R0,[R1, R4]
   \   00000048   0xE003             B        ??ButtonSM_ButtonActive_4
    365                   }
    366                   else
    367                   {
    368                      Button_aeNewState[i] = RELEASED;
   \                     ??ButtonSM_ButtonActive_3: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR      R1,??DataTable13_6
   \   0000004E   0xB2E4             UXTB     R4,R4
   \   00000050   0x5508             STRB     R0,[R1, R4]
    369                   }
    370                  
    371                  /* Update if the button state has changed */
    372                  if( Button_aeNewState[i] != Button_aeCurrentState[i] )
   \                     ??ButtonSM_ButtonActive_4: (+1)
   \   00000052   0x....             LDR      R0,??DataTable13_6
   \   00000054   0xB2E4             UXTB     R4,R4
   \   00000056   0x5D00             LDRB     R0,[R0, R4]
   \   00000058   0x....             LDR      R1,??DataTable13_1
   \   0000005A   0xB2E4             UXTB     R4,R4
   \   0000005C   0x5D09             LDRB     R1,[R1, R4]
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD015             BEQ      ??ButtonSM_ButtonActive_5
    373                  {
    374                    Button_aeCurrentState[i] = Button_aeNewState[i];
   \   00000062   0x....             LDR      R0,??DataTable13_6
   \   00000064   0xB2E4             UXTB     R4,R4
   \   00000066   0x5D00             LDRB     R0,[R0, R4]
   \   00000068   0x....             LDR      R1,??DataTable13_1
   \   0000006A   0xB2E4             UXTB     R4,R4
   \   0000006C   0x5508             STRB     R0,[R1, R4]
    375                    if(Button_aeCurrentState[i] == PRESSED)
   \   0000006E   0x....             LDR      R0,??DataTable13_1
   \   00000070   0xB2E4             UXTB     R4,R4
   \   00000072   0x5D00             LDRB     R0,[R0, R4]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD10A             BNE      ??ButtonSM_ButtonActive_5
    376                    {
    377                      Button_abNewPress[i] = true;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x....             LDR      R1,??DataTable13_2
   \   0000007C   0xB2E4             UXTB     R4,R4
   \   0000007E   0x5508             STRB     R0,[R1, R4]
    378                      Button_au32HoldTimeStart[i] = G_u32SystemTime1ms;
   \   00000080   0x....             LDR      R0,??DataTable13_10
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x....             LDR      R1,??DataTable13_3
   \   00000086   0xB2E4             UXTB     R4,R4
   \   00000088   0x2204             MOVS     R2,#+4
   \   0000008A   0x4362             MULS     R2,R4,R2
   \   0000008C   0x5088             STR      R0,[R1, R2]
    379                    }
    380                  }
    381          
    382                  /* Regardless of a good press or not, clear the debounce active flag and re-enable the interrupts */
    383                  G_abButtonDebounceActive[i] = false;
   \                     ??ButtonSM_ButtonActive_5: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x....             LDR      R1,??DataTable13_5
   \   00000092   0xB2E4             UXTB     R4,R4
   \   00000094   0x5508             STRB     R0,[R1, R4]
    384                  NRF_GPIOTE->INTENSET = (GPIOTE_INTENSET_IN0_Msk | GPIOTE_INTENSET_IN1_Msk | GPIOTE_INTENSET_IN2_Msk);  
   \   00000096   0x2007             MOVS     R0,#+7
   \   00000098   0x....             LDR      R1,??DataTable13_7  ;; 0x40006304
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    385                } /* end if( IsTimeUp...) */
    386              } /* end if(G_abButtonDebounceActive[index]) */
    387            } /* end for i */
   \                     ??ButtonSM_ButtonActive_2: (+1)
   \   0000009C   0x1C64             ADDS     R4,R4,#+1
   \   0000009E   0xE7B4             B        ??ButtonSM_ButtonActive_0
    388          } /* end ButtonSM_ButtonActive() */
   \                     ??ButtonSM_ButtonActive_1: (+1)
   \   000000A0   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x50000508         DC32     0x50000508

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x5000050C         DC32     0x5000050c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x50000510         DC32     0x50000510

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40006510         DC32     0x40006510

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40006100         DC32     0x40006100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     Button_aeCurrentState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     Button_abNewPress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     Button_au32HoldTimeStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     u8ActiveCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     G_abButtonDebounceActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     Button_aeNewState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40006304         DC32     0x40006304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     ButtonSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     Button_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     ButtonSM_ButtonActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     G_au32ButtonDebounceTimeStart
    389          
    390          
    391          
    392          /*--------------------------------------------------------------------------------------------------------------------*/
    393          /* End of File */
    394          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ButtonAcknowledge
       8   ButtonInitialize
         8   -> nrf_gpio_pin_set
         8   -> nrf_gpiote_event_config
       8   ButtonRunActiveState
         8   -- Indirect call
       8   ButtonSM_ButtonActive
         8   -> Button_is_still_pressed
         8   -> IsTimeUp
      16   ButtonSM_Idle
        16   -> Button_rotate_columns
        16   -> SystemEnterCriticalSection
        16   -> SystemExitCriticalSection
       0   Button_get_active_column
      16   Button_is_still_pressed
        16   -> Button_get_active_column
        16   -> nrf_gpio_pin_read
        16 __aeabi_idiv
       8   Button_rotate_columns
         8   -> nrf_gpio_pin_clear
         8   -> nrf_gpio_pin_set
         8 __aeabi_uidivmod
      16   IsButtonHeld
        16   -> IsButtonPressed
        16   -> IsTimeUp
       4   IsButtonPressed
       4   WasButtonPressed
       0   nrf_gpio_pin_clear
       0   nrf_gpio_pin_read
       0   nrf_gpio_pin_set
       8   nrf_gpiote_event_config


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  ButtonAcknowledge
     106  ButtonInitialize
      10  ButtonRunActiveState
     162  ButtonSM_ButtonActive
      64  ButtonSM_Idle
      12  Button_abNewPress
      12  Button_aeCurrentState
      12  Button_aeNewState
      36  Button_au32HoldTimeStart
       6  Button_get_active_column
     102  Button_is_still_pressed
       4  Button_pfnStateMachine
     118  Button_rotate_columns
      12  G_abButtonDebounceActive
      36  G_au32ButtonDebounceTimeStart
      42  IsButtonHeld
      20  IsButtonPressed
      20  WasButtonPressed
      10  nrf_gpio_pin_clear
      14  nrf_gpio_pin_read
      10  nrf_gpio_pin_set
      42  nrf_gpiote_event_config
       1  u8ActiveCol

 
 125 bytes in section .bss
 802 bytes in section .text
 
 802 bytes of CODE memory
 125 bytes of DATA memory

Errors: none
Warnings: none
